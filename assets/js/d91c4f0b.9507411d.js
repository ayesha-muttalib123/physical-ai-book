"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[966],{5494:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"10-Chapter-2-Digital-Twin-Robotics-Examples","title":"Chapter 2: Digital Twin Robotics Examples","description":"Overview","source":"@site/docusaurus/docs/10-Chapter-2-Digital-Twin-Robotics-Examples.md","sourceDirName":".","slug":"/10-Chapter-2-Digital-Twin-Robotics-Examples","permalink":"/physical-ai-book/docs/10-Chapter-2-Digital-Twin-Robotics-Examples","draft":false,"unlisted":false,"editUrl":"https://github.com/ayesha-muttalib123/physical-ai-book/tree/main/docusaurus/docs/10-Chapter-2-Digital-Twin-Robotics-Examples.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"10-Chapter-2-Digital-Twin-Robotics-Examples","title":"Chapter 2: Digital Twin Robotics Examples","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Integrating Unity For Visualization","permalink":"/physical-ai-book/docs/09-Chapter-1-Integrating-Unity-For-Visualization"},"next":{"title":"Chapter 3: Best Practices & Optimization","permalink":"/physical-ai-book/docs/11-Chapter-3-Best-Practices-Optimization"}}');var t=r(4848),o=r(8453);const s={id:"10-Chapter-2-Digital-Twin-Robotics-Examples",title:"Chapter 2: Digital Twin Robotics Examples",sidebar_position:10},a="Chapter 2: Digital Twin Robotics Examples",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Why It Matters",id:"why-it-matters",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Industrial Automation Digital Twins",id:"industrial-automation-digital-twins",level:3},{value:"Autonomous Vehicle Simulation",id:"autonomous-vehicle-simulation",level:3},{value:"Robotic Manipulation Twins",id:"robotic-manipulation-twins",level:3},{value:"Data Synchronization",id:"data-synchronization",level:3},{value:"Hardware-in-the-Loop Testing",id:"hardware-in-the-loop-testing",level:3},{value:"Performance Validation",id:"performance-validation",level:3},{value:"Fleet Management Twins",id:"fleet-management-twins",level:3},{value:"Predictive Maintenance",id:"predictive-maintenance",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Industrial Robot Arm Digital Twin",id:"industrial-robot-arm-digital-twin",level:3},{value:"Autonomous Mobile Robot Fleet Digital Twin",id:"autonomous-mobile-robot-fleet-digital-twin",level:3},{value:"Robotic Manipulation Digital Twin with Force Feedback",id:"robotic-manipulation-digital-twin-with-force-feedback",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Smart Factory Assembly Line",id:"smart-factory-assembly-line",level:3},{value:"Warehouse Logistics Digital Twin",id:"warehouse-logistics-digital-twin",level:3},{value:"Autonomous Delivery Robot Twin",id:"autonomous-delivery-robot-twin",level:3},{value:"Summary",id:"summary",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Estimated Duration",id:"estimated-duration",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-2-digital-twin-robotics-examples",children:"Chapter 2: Digital Twin Robotics Examples"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"This chapter presents comprehensive examples of digital twin implementations using both Gazebo and Unity. Students will work through real-world scenarios that demonstrate the integration of physical and virtual worlds, including industrial automation, autonomous vehicles, and robotic manipulation tasks. Each example showcases best practices for connecting simulation to real hardware and leveraging digital twins for enhanced robot development and deployment."}),"\n",(0,t.jsx)(n.h2,{id:"why-it-matters",children:"Why It Matters"}),"\n",(0,t.jsx)(n.p,{children:"Real-world examples provide essential context for understanding how digital twins are implemented in practice. These examples demonstrate the practical benefits of digital twin technology in robotics, including reduced development time, improved safety, and enhanced testing capabilities. By working through these examples, students gain hands-on experience with the challenges and solutions involved in creating effective digital twin systems."}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"industrial-automation-digital-twins",children:"Industrial Automation Digital Twins"}),"\n",(0,t.jsx)(n.p,{children:"Creating digital replicas of manufacturing environments. These digital twins enable the simulation of complex manufacturing processes, allowing for optimization and validation before deployment on actual production lines."}),"\n",(0,t.jsx)(n.h3,{id:"autonomous-vehicle-simulation",children:"Autonomous Vehicle Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Combining sensor simulation with real-world validation. This involves creating realistic sensor models and environmental conditions that accurately reflect real-world scenarios for testing autonomous vehicles."}),"\n",(0,t.jsx)(n.h3,{id:"robotic-manipulation-twins",children:"Robotic Manipulation Twins"}),"\n",(0,t.jsx)(n.p,{children:"Bridging simulation and reality for dexterous tasks. These digital twins focus on precise manipulation tasks, incorporating force feedback and haptic interfaces to enhance the realism of the simulation."}),"\n",(0,t.jsx)(n.h3,{id:"data-synchronization",children:"Data Synchronization"}),"\n",(0,t.jsx)(n.p,{children:"Aligning real sensor data with simulated environments. This involves maintaining temporal and spatial consistency between real and simulated systems to ensure accurate representation."}),"\n",(0,t.jsx)(n.h3,{id:"hardware-in-the-loop-testing",children:"Hardware-in-the-Loop Testing"}),"\n",(0,t.jsx)(n.p,{children:"Integrating real hardware with simulated environments. This approach combines physical components with virtual simulation to validate system behavior in realistic conditions."}),"\n",(0,t.jsx)(n.h3,{id:"performance-validation",children:"Performance Validation"}),"\n",(0,t.jsx)(n.p,{children:"Comparing real vs. simulated robot behaviors. This involves developing metrics and methodologies to assess the accuracy and effectiveness of digital twin implementations."}),"\n",(0,t.jsx)(n.h3,{id:"fleet-management-twins",children:"Fleet Management Twins"}),"\n",(0,t.jsx)(n.p,{children:"Digital twins for multi-robot systems. These digital twins manage and coordinate multiple robots, optimizing fleet performance and resource allocation."}),"\n",(0,t.jsx)(n.h3,{id:"predictive-maintenance",children:"Predictive Maintenance"}),"\n",(0,t.jsx)(n.p,{children:"Using digital twins for equipment monitoring and maintenance. Digital twins can monitor equipment health and predict maintenance needs, reducing downtime and extending equipment life."}),"\n",(0,t.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(n.h3,{id:"industrial-robot-arm-digital-twin",children:"Industrial Robot Arm Digital Twin"}),"\n",(0,t.jsx)(n.p,{children:"Implementation of a digital twin for an industrial robot arm with real-time synchronization:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom control_msgs.msg import JointTrajectoryControllerState\r\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nimport numpy as np\r\nimport time\r\n\r\nclass IndustrialArmDigitalTwin(Node):\r\n    def __init__(self):\r\n        super().__init__('industrial_arm_digital_twin')\r\n\r\n        # Real robot joint state subscriber\r\n        self.real_joint_sub = self.create_subscription(\r\n            JointState,\r\n            '/real_robot/joint_states',\r\n            self.real_joint_callback,\r\n            10\r\n        )\r\n\r\n        # Simulated robot joint command publisher\r\n        self.sim_cmd_pub = self.create_publisher(\r\n            JointTrajectory,\r\n            '/sim_robot/joint_trajectory_controller/joint_trajectory',\r\n            10\r\n        )\r\n\r\n        # Simulated robot joint state subscriber\r\n        self.sim_joint_sub = self.create_subscription(\r\n            JointState,\r\n            '/sim_robot/joint_states',\r\n            self.sim_joint_callback,\r\n            10\r\n        )\r\n\r\n        # Real robot command publisher\r\n        self.real_cmd_pub = self.create_publisher(\r\n            JointTrajectory,\r\n            '/real_robot/joint_trajectory_controller/joint_trajectory',\r\n            10\r\n        )\r\n\r\n        # Timer for synchronization\r\n        self.timer = self.create_timer(0.1, self.synchronization_callback)  # 10Hz\r\n\r\n        # State storage\r\n        self.real_joints = {}\r\n        self.sim_joints = {}\r\n        self.sync_enabled = True\r\n\r\n    def real_joint_callback(self, msg):\r\n        \"\"\"Receive joint states from the real robot\"\"\"\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.real_joints[name] = {\r\n                    'position': msg.position[i],\r\n                    'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\r\n                    'effort': msg.effort[i] if i < len(msg.effort) else 0.0,\r\n                    'timestamp': self.get_clock().now().to_msg()\r\n                }\r\n\r\n    def sim_joint_callback(self, msg):\r\n        \"\"\"Receive joint states from the simulated robot\"\"\"\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.sim_joints[name] = {\r\n                    'position': msg.position[i],\r\n                    'velocity': msg.velocity[i] if i < len(msg.velocity) else 0.0,\r\n                    'effort': msg.effort[i] if i < len(msg.effort) else 0.0,\r\n                    'timestamp': self.get_clock().now().to_msg()\r\n                }\r\n\r\n    def synchronization_callback(self):\r\n        \"\"\"Synchronize real and simulated robot states\"\"\"\r\n        if not self.sync_enabled:\r\n            return\r\n\r\n        # Option 1: Send real robot state to simulation (for visualization)\r\n        if self.should_update_simulation():\r\n            self.update_simulation_from_real()\r\n\r\n        # Option 2: Send simulated commands to real robot (for validation)\r\n        if self.should_update_real_robot():\r\n            self.update_real_robot_from_simulation()\r\n\r\n    def should_update_simulation(self):\r\n        \"\"\"Determine if simulation should be updated from real robot\"\"\"\r\n        # In real applications, this could be based on various criteria\r\n        return True\r\n\r\n    def should_update_real_robot(self):\r\n        \"\"\"Determine if real robot should be updated from simulation\"\"\"\r\n        # Only update real robot during testing or validation phases\r\n        return False  # Disabled by default for safety\r\n\r\n    def update_simulation_from_real(self):\r\n        \"\"\"Send real robot state to simulation for visualization\"\"\"\r\n        if not self.real_joints:\r\n            return\r\n\r\n        # Create trajectory message with current real positions\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.header.stamp = self.get_clock().now().to_msg()\r\n        traj_msg.joint_names = list(self.real_joints.keys())\r\n\r\n        point = JointTrajectoryPoint()\r\n        for joint_name in traj_msg.joint_names:\r\n            joint_data = self.real_joints[joint_name]\r\n            point.positions.append(joint_data['position'])\r\n            point.velocities.append(joint_data['velocity'])\r\n            point.effort.append(joint_data['effort'])\r\n\r\n        point.time_from_start.sec = 0\r\n        point.time_from_start.nanosec = 100000000  # 0.1 seconds\r\n\r\n        traj_msg.points.append(point)\r\n        self.sim_cmd_pub.publish(traj_msg)\r\n\r\n    def update_real_robot_from_simulation(self):\r\n        \"\"\"Send simulated commands to real robot for validation\"\"\"\r\n        if not self.sim_joints:\r\n            return\r\n\r\n        # In a real implementation, this would be much more sophisticated\r\n        # and include safety checks and validation\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.header.stamp = self.get_clock().now().to_msg()\r\n        traj_msg.joint_names = list(self.sim_joints.keys())\r\n\r\n        point = JointTrajectoryPoint()\r\n        for joint_name in traj_msg.joint_names:\r\n            joint_data = self.sim_joints[joint_name]\r\n            point.positions.append(joint_data['position'])\r\n            point.velocities.append(joint_data['velocity'])\r\n            point.effort.append(joint_data['effort'])\r\n\r\n        point.time_from_start.sec = 0\r\n        point.time_from_start.nanosec = 100000000  # 0.1 seconds\r\n\r\n        traj_msg.points.append(point)\r\n        self.real_cmd_pub.publish(traj_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = IndustrialArmDigitalTwin()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down industrial arm digital twin...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"autonomous-mobile-robot-fleet-digital-twin",children:"Autonomous Mobile Robot Fleet Digital Twin"}),"\n",(0,t.jsx)(n.p,{children:"Digital twin implementation for a fleet of mobile robots with real-time tracking and simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom nav_msgs.msg import Odometry\r\nfrom std_msgs.msg import Float32\r\nfrom visualization_msgs.msg import MarkerArray, Marker\r\nimport numpy as np\r\nimport math\r\nfrom collections import defaultdict\r\n\r\nclass MobileRobotFleetDigitalTwin(Node):\r\n    def __init__(self):\r\n        super().__init__('mobile_fleet_digital_twin')\r\n\r\n        # Fleet state storage\r\n        self.robot_states = defaultdict(dict)\r\n        self.robot_goals = defaultdict(None)\r\n        self.fleet_metrics = {\r\n            'total_distance_traveled': defaultdict(float),\r\n            'total_operational_time': defaultdict(0.0),\r\n            'average_speed': defaultdict(float),\r\n            'collision_count': defaultdict(int),\r\n            'task_completion_rate': defaultdict(float)\r\n        }\r\n\r\n        # Publishers and subscribers\r\n        self.odom_subs = {}\r\n        self.cmd_vel_pubs = {}\r\n        self.sim_odom_subs = {}\r\n        self.sim_cmd_pubs = {}\r\n        self.visualization_pub = self.create_publisher(MarkerArray, '/fleet_visualization', 10)\r\n        self.metrics_pub = self.create_publisher(Float32, '/fleet_metrics', 10)\r\n\r\n        # Timer for periodic tasks\r\n        self.timer = self.create_timer(0.5, self.periodic_tasks)\r\n\r\n        # Fleet configuration\r\n        self.fleet_size = 5\r\n        self.robot_names = [f'robot_{i}' for i in range(self.fleet_size)]\r\n        self.initialize_fleet()\r\n\r\n    def initialize_fleet(self):\r\n        \"\"\"Initialize subscribers and publishers for each robot\"\"\"\r\n        for robot_name in self.robot_names:\r\n            # Real robot subscribers\r\n            self.odom_subs[robot_name] = self.create_subscription(\r\n                Odometry,\r\n                f'/{robot_name}/odometry/filtered',\r\n                lambda msg, rn=robot_name: self.real_odom_callback(msg, rn),\r\n                10\r\n            )\r\n\r\n            # Real robot publishers\r\n            self.cmd_vel_pubs[robot_name] = self.create_publisher(\r\n                Twist,\r\n                f'/{robot_name}/cmd_vel',\r\n                10\r\n            )\r\n\r\n            # Simulated robot subscribers\r\n            self.sim_odom_subs[robot_name] = self.create_subscription(\r\n                Odometry,\r\n                f'/sim_{robot_name}/odometry/filtered',\r\n                lambda msg, rn=robot_name: self.sim_odom_callback(msg, rn),\r\n                10\r\n            )\r\n\r\n            # Simulated robot publishers\r\n            self.sim_cmd_pubs[robot_name] = self.create_publisher(\r\n                Twist,\r\n                f'/sim_{robot_name}/cmd_vel',\r\n                10\r\n            )\r\n\r\n    def real_odom_callback(self, msg, robot_name):\r\n        \"\"\"Process odometry from real robot\"\"\"\r\n        self.robot_states[robot_name]['real'] = {\r\n            'pose': msg.pose.pose,\r\n            'twist': msg.twist.twist,\r\n            'timestamp': msg.header.stamp\r\n        }\r\n\r\n        # Update fleet metrics\r\n        self.update_metrics(robot_name, 'real', msg)\r\n\r\n    def sim_odom_callback(self, msg, robot_name):\r\n        \"\"\"Process odometry from simulated robot\"\"\"\r\n        self.robot_states[robot_name]['sim'] = {\r\n            'pose': msg.pose.pose,\r\n            'twist': msg.twist.twist,\r\n            'timestamp': msg.header.stamp\r\n        }\r\n\r\n        # Update fleet metrics\r\n        self.update_metrics(robot_name, 'sim', msg)\r\n\r\n    def update_metrics(self, robot_name, source, odom_msg):\r\n        \"\"\"Update fleet metrics based on robot data\"\"\"\r\n        if source == 'real':\r\n            # Update real robot metrics\r\n            pose = odom_msg.pose.pose\r\n            twist = odom_msg.twist.twist\r\n\r\n            # Calculate distance traveled incrementally\r\n            if f'last_pose_{source}' in self.robot_states[robot_name]:\r\n                last_pose = self.robot_states[robot_name][f'last_pose_{source}']\r\n                distance = self.calculate_distance(pose, last_pose)\r\n                self.fleet_metrics['total_distance_traveled'][robot_name] += distance\r\n\r\n            self.robot_states[robot_name][f'last_pose_{source}'] = pose\r\n            self.fleet_metrics['average_speed'][robot_name] = twist.linear.x\r\n\r\n    def calculate_distance(self, pose1, pose2):\r\n        \"\"\"Calculate Euclidean distance between two poses\"\"\"\r\n        dx = pose1.position.x - pose2.position.x\r\n        dy = pose1.position.y - pose2.position.y\r\n        dz = pose1.position.z - pose2.position.z\r\n        return math.sqrt(dx*dx + dy*dy + dz*dz)\r\n\r\n    def periodic_tasks(self):\r\n        \"\"\"Execute periodic tasks for fleet management\"\"\"\r\n        # Update visualization\r\n        self.update_visualization()\r\n\r\n        # Compare real vs simulated performance\r\n        self.compare_real_sim_performance()\r\n\r\n        # Check for anomalies\r\n        self.check_anomalies()\r\n\r\n    def update_visualization(self):\r\n        \"\"\"Update fleet visualization markers\"\"\"\r\n        marker_array = MarkerArray()\r\n\r\n        for i, robot_name in enumerate(self.robot_names):\r\n            if 'real' in self.robot_states[robot_name]:\r\n                # Real robot marker\r\n                real_marker = Marker()\r\n                real_marker.header.frame_id = \"map\"\r\n                real_marker.header.stamp = self.get_clock().now().to_msg()\r\n                real_marker.ns = \"real_robots\"\r\n                real_marker.id = i * 2\r\n                real_marker.type = Marker.CYLINDER\r\n                real_marker.action = Marker.ADD\r\n\r\n                real_pose = self.robot_states[robot_name]['real']['pose']\r\n                real_marker.pose.position = real_pose.position\r\n                real_marker.pose.orientation = real_pose.orientation\r\n\r\n                real_marker.scale.x = 0.5\r\n                real_marker.scale.y = 0.5\r\n                real_marker.scale.z = 0.2\r\n\r\n                real_marker.color.a = 0.8  # Alpha\r\n                real_marker.color.r = 1.0  # Red\r\n                real_marker.color.g = 0.0\r\n                real_marker.color.b = 0.0\r\n\r\n                marker_array.markers.append(real_marker)\r\n\r\n            if 'sim' in self.robot_states[robot_name]:\r\n                # Simulated robot marker\r\n                sim_marker = Marker()\r\n                sim_marker.header.frame_id = \"map\"\r\n                sim_marker.header.stamp = self.get_clock().now().to_msg()\r\n                sim_marker.ns = \"sim_robots\"\r\n                sim_marker.id = i * 2 + 1\r\n                sim_marker.type = Marker.CUBE\r\n                sim_marker.action = Marker.ADD\r\n\r\n                sim_pose = self.robot_states[robot_name]['sim']['pose']\r\n                sim_marker.pose.position = sim_pose.position\r\n                sim_marker.pose.orientation = sim_pose.orientation\r\n\r\n                sim_marker.scale.x = 0.5\r\n                sim_marker.scale.y = 0.5\r\n                sim_marker.scale.z = 0.2\r\n\r\n                sim_marker.color.a = 0.6  # Alpha\r\n                sim_marker.color.r = 0.0  # Blue\r\n                sim_marker.color.g = 0.0\r\n                sim_marker.color.b = 1.0\r\n\r\n                marker_array.markers.append(sim_marker)\r\n\r\n        self.visualization_pub.publish(marker_array)\r\n\r\n    def compare_real_sim_performance(self):\r\n        \"\"\"Compare real and simulated robot performance\"\"\"\r\n        for robot_name in self.robot_names:\r\n            if 'real' in self.robot_states[robot_name] and 'sim' in self.robot_states[robot_name]:\r\n                real_pose = self.robot_states[robot_name]['real']['pose']\r\n                sim_pose = self.robot_states[robot_name]['sim']['pose']\r\n\r\n                # Calculate position difference\r\n                pos_diff = self.calculate_distance(real_pose, sim_pose)\r\n\r\n                # Log differences for analysis\r\n                if pos_diff > 0.5:  # Threshold for significant difference\r\n                    self.get_logger().warn(f'Large position difference for {robot_name}: {pos_diff:.2f}m')\r\n\r\n    def check_anomalies(self):\r\n        \"\"\"Check for anomalies in fleet behavior\"\"\"\r\n        for robot_name in self.robot_names:\r\n            if 'real' in self.robot_states[robot_name]:\r\n                # Check for collision indicators (abrupt velocity changes)\r\n                twist = self.robot_states[robot_name]['real']['twist']\r\n                speed = math.sqrt(twist.linear.x**2 + twist.linear.y**2)\r\n\r\n                if hasattr(self, f'last_speed_{robot_name}'):\r\n                    speed_change = abs(speed - getattr(self, f'last_speed_{robot_name}'))\r\n                    if speed_change > 2.0:  # Significant acceleration\r\n                        self.get_logger().info(f'Potential collision detected for {robot_name}')\r\n                        self.fleet_metrics['collision_count'][robot_name] += 1\r\n\r\n                setattr(self, f'last_speed_{robot_name}', speed)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = MobileRobotFleetDigitalTwin()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down fleet digital twin...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"robotic-manipulation-digital-twin-with-force-feedback",children:"Robotic Manipulation Digital Twin with Force Feedback"}),"\n",(0,t.jsx)(n.p,{children:"Digital twin for robotic manipulation with haptic feedback and force sensing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, WrenchStamped\r\nfrom geometry_msgs.msg import Wrench, PoseStamped\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport numpy as np\r\nimport math\r\n\r\nclass ManipulationDigitalTwin(Node):\r\n    def __init__(self):\r\n        super().__init__('manipulation_digital_twin')\r\n\r\n        # Publishers and subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState,\r\n            '/real_manipulator/joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        self.force_torque_sub = self.create_subscription(\r\n            WrenchStamped,\r\n            '/real_manipulator/wrench',\r\n            self.force_torque_callback,\r\n            10\r\n        )\r\n\r\n        self.end_effector_pose_sub = self.create_subscription(\r\n            PoseStamped,\r\n            '/real_manipulator/end_effector_pose',\r\n            self.end_effector_pose_callback,\r\n            10\r\n        )\r\n\r\n        self.sim_joint_cmd_pub = self.create_publisher(\r\n            Float64MultiArray,\r\n            '/sim_manipulator/joint_group_position_controller/commands',\r\n            10\r\n        )\r\n\r\n        self.haptic_feedback_pub = self.create_publisher(\r\n            Wrench,\r\n            '/haptic_device/force_feedback',\r\n            10\r\n        )\r\n\r\n        # Timer for processing\r\n        self.timer = self.create_timer(0.05, self.process_callback)  # 20Hz\r\n\r\n        # State storage\r\n        self.current_joints = None\r\n        self.current_force = None\r\n        self.current_pose = None\r\n        self.simulated_environment = None\r\n        self.contact_points = []\r\n\r\n    def joint_state_callback(self, msg):\r\n        \"\"\"Process joint state from real manipulator\"\"\"\r\n        self.current_joints = {\r\n            'positions': msg.position,\r\n            'velocities': msg.velocity,\r\n            'efforts': msg.effort,\r\n            'names': msg.name\r\n        }\r\n\r\n    def force_torque_callback(self, msg):\r\n        \"\"\"Process force/torque sensor data\"\"\"\r\n        self.current_force = {\r\n            'force': [msg.wrench.force.x, msg.wrench.force.y, msg.wrench.force.z],\r\n            'torque': [msg.wrench.torque.x, msg.wrench.torque.y, msg.wrench.torque.z],\r\n            'timestamp': msg.header.stamp\r\n        }\r\n\r\n    def end_effector_pose_callback(self, msg):\r\n        \"\"\"Process end effector pose\"\"\"\r\n        self.current_pose = {\r\n            'position': [msg.pose.position.x, msg.pose.position.y, msg.pose.position.z],\r\n            'orientation': [msg.pose.orientation.x, msg.pose.orientation.y,\r\n                           msg.pose.orientation.z, msg.pose.orientation.w]\r\n        }\r\n\r\n    def process_callback(self):\r\n        \"\"\"Process digital twin operations\"\"\"\r\n        if self.current_joints is not None:\r\n            # Update simulated manipulator to match real manipulator\r\n            self.update_simulation()\r\n\r\n        if self.current_force is not None and self.current_pose is not None:\r\n            # Calculate haptic feedback based on environment interaction\r\n            self.calculate_haptic_feedback()\r\n\r\n    def update_simulation(self):\r\n        \"\"\"Send real manipulator state to simulation\"\"\"\r\n        cmd_msg = Float64MultiArray()\r\n        cmd_msg.data = list(self.current_joints['positions'])\r\n        self.sim_joint_cmd_pub.publish(cmd_msg)\r\n\r\n    def calculate_haptic_feedback(self):\r\n        \"\"\"Calculate haptic feedback based on force sensing and environment\"\"\"\r\n        # Simulate contact forces based on end-effector position and environment\r\n        if self.simulated_environment:\r\n            # Calculate forces based on proximity to objects in simulation\r\n            feedback_force = self.calculate_interaction_forces()\r\n        else:\r\n            # Use real force sensor data for haptic feedback\r\n            feedback_force = Wrench()\r\n            feedback_force.force.x = self.current_force['force'][0] * 0.1  # Scale down\r\n            feedback_force.force.y = self.current_force['force'][1] * 0.1\r\n            feedback_force.force.z = self.current_force['force'][2] * 0.1\r\n            feedback_force.torque.x = self.current_force['torque'][0] * 0.1\r\n            feedback_force.torque.y = self.current_force['torque'][1] * 0.1\r\n            feedback_force.torque.z = self.current_force['torque'][2] * 0.1\r\n\r\n        self.haptic_feedback_pub.publish(feedback_force)\r\n\r\n    def calculate_interaction_forces(self):\r\n        \"\"\"Calculate interaction forces based on simulated environment\"\"\"\r\n        # This would typically involve collision detection with simulated objects\r\n        # For this example, we'll simulate contact with a virtual surface\r\n        ee_pos = self.current_pose['position']\r\n\r\n        # Virtual surface at z = 0.1m\r\n        surface_z = 0.1\r\n        distance_to_surface = max(0, ee_pos[2] - surface_z)\r\n\r\n        # Generate repulsive force when close to surface\r\n        if distance_to_surface < 0.05:  # Within 5cm\r\n            force_magnitude = max(0, 0.05 - distance_to_surface) * 100  # Stiffness\r\n            feedback_force = Wrench()\r\n            feedback_force.force.z = -force_magnitude  # Push away from surface\r\n            return feedback_force\r\n        else:\r\n            return Wrench()  # No force\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ManipulationDigitalTwin()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down manipulation digital twin...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(n.h3,{id:"smart-factory-assembly-line",children:"Smart Factory Assembly Line"}),"\n",(0,t.jsx)(n.p,{children:"Students implement a digital twin for an assembly line with multiple robotic arms performing coordinated tasks."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Design digital twin architecture for multi-robot coordination"}),"\n",(0,t.jsx)(n.li,{children:"Implement real-time synchronization between real and simulated robots"}),"\n",(0,t.jsx)(n.li,{children:"Create visualization dashboard for monitoring assembly line status"}),"\n",(0,t.jsx)(n.li,{children:"Develop predictive maintenance algorithms using digital twin data"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Industrial robot arms (real or simulated)"}),"\n",(0,t.jsx)(n.li,{children:"Conveyor belt system"}),"\n",(0,t.jsx)(n.li,{children:"Vision systems for quality control"}),"\n",(0,t.jsx)(n.li,{children:"Assembly line components and fixtures"}),"\n",(0,t.jsx)(n.li,{children:"Network infrastructure for real-time communication"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Accuracy of digital twin synchronization"}),"\n",(0,t.jsx)(n.li,{children:"Coordination effectiveness of multiple robots"}),"\n",(0,t.jsx)(n.li,{children:"Response time to system changes"}),"\n",(0,t.jsx)(n.li,{children:"Quality of visualization and monitoring interfaces"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"warehouse-logistics-digital-twin",children:"Warehouse Logistics Digital Twin"}),"\n",(0,t.jsx)(n.p,{children:"Students create a digital twin for an automated warehouse with AMRs, conveyor systems, and inventory management."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Model complex warehouse logistics in simulation"}),"\n",(0,t.jsx)(n.li,{children:"Implement fleet management algorithms"}),"\n",(0,t.jsx)(n.li,{children:"Integrate with real warehouse management systems"}),"\n",(0,t.jsx)(n.li,{children:"Validate performance metrics against real data"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Autonomous mobile robots (AMRs)"}),"\n",(0,t.jsx)(n.li,{children:"Warehouse management software"}),"\n",(0,t.jsx)(n.li,{children:"Inventory tracking systems"}),"\n",(0,t.jsx)(n.li,{children:"RFID or barcode scanning systems"}),"\n",(0,t.jsx)(n.li,{children:"Communication infrastructure"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Fleet utilization efficiency"}),"\n",(0,t.jsx)(n.li,{children:"Order fulfillment accuracy"}),"\n",(0,t.jsx)(n.li,{children:"System scalability under load"}),"\n",(0,t.jsx)(n.li,{children:"Integration with existing warehouse systems"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"autonomous-delivery-robot-twin",children:"Autonomous Delivery Robot Twin"}),"\n",(0,t.jsx)(n.p,{children:"Students develop a digital twin for an outdoor delivery robot with complex navigation and obstacle avoidance."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create realistic outdoor environment simulation"}),"\n",(0,t.jsx)(n.li,{children:"Implement multi-sensor fusion for navigation"}),"\n",(0,t.jsx)(n.li,{children:"Test safety protocols in simulation before real deployment"}),"\n",(0,t.jsx)(n.li,{children:"Analyze performance in various weather conditions"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Delivery robot platform"}),"\n",(0,t.jsx)(n.li,{children:"GPS and IMU sensors"}),"\n",(0,t.jsx)(n.li,{children:"LIDAR and camera systems"}),"\n",(0,t.jsx)(n.li,{children:"Weather simulation tools"}),"\n",(0,t.jsx)(n.li,{children:"Safety validation protocols"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Navigation accuracy and safety"}),"\n",(0,t.jsx)(n.li,{children:"Adaptation to environmental changes"}),"\n",(0,t.jsx)(n.li,{children:"Delivery success rate"}),"\n",(0,t.jsx)(n.li,{children:"Energy efficiency optimization"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Chapter 9 provided comprehensive examples of digital twin implementations in robotics, covering industrial automation, fleet management, and manipulation tasks. Students learned to create synchronized systems that bridge real and simulated environments, implementing real-time data exchange and visualization. The practical examples demonstrated the value of digital twins in improving robot development, testing, and deployment across various applications."}),"\n",(0,t.jsx)(n.h2,{id:"quiz",children:"Quiz"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is a primary benefit of using digital twins in robotics?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A: Reduced hardware costs"}),"\n",(0,t.jsx)(n.li,{children:"B: Ability to test and validate in safe simulated environment"}),"\n",(0,t.jsx)(n.li,{children:"C: Faster robot movement"}),"\n",(0,t.jsx)(n.li,{children:"D: Simplified robot programming"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer: B"})," - Digital twins allow for testing and validation in safe simulated environments before deploying to real robots, reducing risks and development time."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What does hardware-in-the-loop testing involve?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A: Testing without any hardware"}),"\n",(0,t.jsx)(n.li,{children:"B: Integrating real hardware with simulated environments"}),"\n",(0,t.jsx)(n.li,{children:"C: Testing only in simulation"}),"\n",(0,t.jsx)(n.li,{children:"D: Hardware that loops back on itself"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer: B"})," - Hardware-in-the-loop testing involves integrating real hardware components with simulated environments to validate system behavior."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is an important consideration when synchronizing real and simulated robots?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A: Robot color matching"}),"\n",(0,t.jsx)(n.li,{children:"B: Timing and data consistency"}),"\n",(0,t.jsx)(n.li,{children:"C: Same manufacturer requirements"}),"\n",(0,t.jsx)(n.li,{children:"D: Identical robot sizes"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer: B"})," - Timing and data consistency are crucial when synchronizing real and simulated robots to ensure accurate representation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Which metric would be most important for evaluating a fleet digital twin?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A: Individual robot weight"}),"\n",(0,t.jsx)(n.li,{children:"B: Fleet utilization efficiency"}),"\n",(0,t.jsx)(n.li,{children:"C: Battery brand used"}),"\n",(0,t.jsx)(n.li,{children:"D: Number of robot joints"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer: B"})," - Fleet utilization efficiency is a key metric for evaluating fleet digital twins as it measures how effectively the robot fleet operates."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"What is the purpose of comparing real vs. simulated performance?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A: To make simulation more complex"}),"\n",(0,t.jsx)(n.li,{children:"B: To validate simulation accuracy and identify discrepancies"}),"\n",(0,t.jsx)(n.li,{children:"C: To eliminate the need for real robots"}),"\n",(0,t.jsx)(n.li,{children:"D: To slow down the system"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer: B"})," - Comparing real vs. simulated performance validates simulation accuracy and helps identify discrepancies that need to be addressed."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(n.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create simulation environments for robot testing"}),"\n",(0,t.jsx)(n.li,{children:"Implement physics-based simulations"}),"\n",(0,t.jsx)(n.li,{children:"Bridge simulation and reality"}),"\n",(0,t.jsx)(n.li,{children:"Validate robot behaviors in simulation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Basic understanding of Python programming"}),"\n",(0,t.jsx)(n.li,{children:"Fundamentals of linear algebra and calculus"}),"\n",(0,t.jsx)(n.li,{children:"Basic knowledge of robotics concepts"}),"\n",(0,t.jsx)(n.li,{children:"Introduction to machine learning concepts"}),"\n",(0,t.jsx)(n.li,{children:"Completion of Module 0 (Introduction and Foundations)"}),"\n",(0,t.jsx)(n.li,{children:"Completion of Chapter 01 (Physical AI Basics)"}),"\n",(0,t.jsx)(n.li,{children:"Completion of Chapter 06 (Introduction to Digital Twins)"}),"\n",(0,t.jsx)(n.li,{children:"Completion of Chapter 07 (Gazebo Simulation Basics)"}),"\n",(0,t.jsx)(n.li,{children:"Completion of Chapter 08 (Integrating Unity for Visualization)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"estimated-duration",children:"Estimated Duration"}),"\n",(0,t.jsx)(n.p,{children:"6 hours"})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var i=r(6540);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);