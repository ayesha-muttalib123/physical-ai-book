"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[424],{7795:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>_,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"18-Chapter-2-Humanoid-Locomotion-Control","title":"Chapter 2: Humanoid Locomotion & Control","description":"Overview","source":"@site/docusaurus/docs/18-Chapter-2-Humanoid-Locomotion-Control.md","sourceDirName":".","slug":"/18-Chapter-2-Humanoid-Locomotion-Control","permalink":"/physical-ai-book/docs/18-Chapter-2-Humanoid-Locomotion-Control","draft":false,"unlisted":false,"editUrl":"https://github.com/ayesha-muttalib123/physical-ai-book/tree/main/docusaurus/docs/18-Chapter-2-Humanoid-Locomotion-Control.md","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"id":"18-Chapter-2-Humanoid-Locomotion-Control","title":"Chapter 2: Humanoid Locomotion & Control","sidebar_position":18},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Vision-Language-Action Concepts","permalink":"/physical-ai-book/docs/17-Chapter-1-Vision-Language-Action-Concepts"},"next":{"title":"Chapter 3: Vision-Based Navigation Examples","permalink":"/physical-ai-book/docs/19-Chapter-3-Vision-Based-Navigation-Examples"}}');var o=t(4848),i=t(8453);const s={id:"18-Chapter-2-Humanoid-Locomotion-Control",title:"Chapter 2: Humanoid Locomotion & Control",sidebar_position:18},a="Chapter 2: Humanoid Locomotion & Control",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Why It Matters",id:"why-it-matters",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Whole-Body Control",id:"whole-body-control",level:3},{value:"Balance Control",id:"balance-control",level:3},{value:"Gait Generation",id:"gait-generation",level:3},{value:"Dynamic Walking",id:"dynamic-walking",level:3},{value:"Zero Moment Point (ZMP)",id:"zero-moment-point-zmp",level:3},{value:"Center of Mass Control",id:"center-of-mass-control",level:3},{value:"Feedback Control",id:"feedback-control",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"Inverse Kinematics for Humanoid Legs",id:"inverse-kinematics-for-humanoid-legs",level:3},{value:"Whole-Body Control for Humanoid Balance",id:"whole-body-control-for-humanoid-balance",level:3},{value:"Dynamic Walking Pattern Generation",id:"dynamic-walking-pattern-generation",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Humanoid Balance Control System",id:"humanoid-balance-control-system",level:3},{value:"Dynamic Walking Gait Generation",id:"dynamic-walking-gait-generation",level:3},{value:"Humanoid Locomotion Learning",id:"humanoid-locomotion-learning",level:3},{value:"Summary",id:"summary",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Estimated Duration",id:"estimated-duration",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-2-humanoid-locomotion--control",children:"Chapter 2: Humanoid Locomotion & Control"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"This chapter explores the complex field of humanoid locomotion and control, covering the biomechanics of human-like movement, balance control, and gait generation. Students will learn about various approaches to humanoid locomotion including inverse kinematics, whole-body control, and dynamic balance maintenance. The chapter covers both theoretical foundations and practical implementation of control systems for humanoid robots, with emphasis on stability, efficiency, and human-like movement patterns."}),"\n",(0,o.jsx)(e.h2,{id:"why-it-matters",children:"Why It Matters"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid locomotion and control are fundamental to creating robots that can operate in human environments and interact naturally with human-designed infrastructure. Understanding these concepts is crucial for developing robots that can walk, balance, and move like humans, enabling them to navigate stairs, doors, and other human-centric environments. The principles learned in this chapter are essential for creating safe, stable, and efficient humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.p,{children:"Mathematical methods for determining joint angles from end-effector positions. This involves solving the problem of how to position a robot's joints to achieve a desired position and orientation of its end effectors (hands, feet)."}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-control",children:"Whole-Body Control"}),"\n",(0,o.jsx)(e.p,{children:"Coordinated control of all robot joints for stable movement. This approach considers the entire robot as a single system and optimizes the behavior of all joints simultaneously to achieve desired tasks while maintaining balance and stability."}),"\n",(0,o.jsx)(e.h3,{id:"balance-control",children:"Balance Control"}),"\n",(0,o.jsx)(e.p,{children:"Techniques for maintaining center of mass within support polygon. This involves continuously adjusting the robot's posture and movements to keep its center of mass over its support base to prevent falling."}),"\n",(0,o.jsx)(e.h3,{id:"gait-generation",children:"Gait Generation"}),"\n",(0,o.jsx)(e.p,{children:"Algorithms for creating stable walking patterns. This includes planning the trajectories for feet, center of mass, and other body parts to create natural and stable walking motions."}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-walking",children:"Dynamic Walking"}),"\n",(0,o.jsx)(e.p,{children:"Control strategies for stable dynamic locomotion. This involves controlling the robot during the phases when both feet are off the ground, requiring precise control to maintain balance."}),"\n",(0,o.jsx)(e.h3,{id:"zero-moment-point-zmp",children:"Zero Moment Point (ZMP)"}),"\n",(0,o.jsx)(e.p,{children:"Concept for maintaining dynamic balance. The ZMP is a point on the ground where the net moment of the ground reaction forces equals zero, serving as a key metric for balance control in walking robots."}),"\n",(0,o.jsx)(e.h3,{id:"center-of-mass-control",children:"Center of Mass Control"}),"\n",(0,o.jsx)(e.p,{children:"Managing robot's center of mass for stability. This involves tracking and controlling the position of the robot's center of mass to ensure it remains within the support polygon defined by the feet."}),"\n",(0,o.jsx)(e.h3,{id:"feedback-control",children:"Feedback Control"}),"\n",(0,o.jsx)(e.p,{children:"Using sensor feedback for stable locomotion. This involves using data from sensors like IMUs, joint encoders, and force sensors to adjust the robot's movements in real-time to maintain balance and achieve goals."}),"\n",(0,o.jsx)(e.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics-for-humanoid-legs",children:"Inverse Kinematics for Humanoid Legs"}),"\n",(0,o.jsx)(e.p,{children:"Implementation of inverse kinematics for controlling humanoid leg movements:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nInverse Kinematics for Humanoid Legs\r\nDemonstrates inverse kinematics for controlling humanoid leg movements\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import Point, Pose\r\nfrom std_msgs.msg import Float64MultiArray\r\nimport numpy as np\r\nimport math\r\nfrom typing import List, Tuple\r\n\r\nclass HumanoidIKSolver:\r\n    """Inverse kinematics solver for humanoid leg"""\r\n    def __init__(self, hip_offset=0.1, thigh_length=0.4, shin_length=0.4, foot_length=0.1):\r\n        self.hip_offset = hip_offset      # Distance from body to hip joint\r\n        self.thigh_length = thigh_length  # Length of thigh\r\n        self.shin_length = shin_length    # Length of shin\r\n        self.foot_length = foot_length    # Length of foot\r\n\r\n    def leg_ik_3dof(self, target_x, target_y, target_z) -> Tuple[float, float, float]:\r\n        """\r\n        Solve 3-DOF leg inverse kinematics (hip, knee, ankle)\r\n        Returns: (hip_angle, knee_angle, ankle_angle)\r\n        """\r\n        # Calculate hip angle (yaw) - this is simplified\r\n        hip_yaw = math.atan2(target_y, target_x)\r\n\r\n        # Project target onto sagittal plane (XZ plane)\r\n        target_distance = math.sqrt(target_x**2 + target_y**2)\r\n        hip_x = target_distance - self.hip_offset\r\n        hip_z = target_z\r\n\r\n        # Calculate distance from hip to target in sagittal plane\r\n        distance = math.sqrt(hip_x**2 + hip_z**2)\r\n\r\n        # Check if target is reachable\r\n        if distance > self.thigh_length + self.shin_length:\r\n            # Target too far, extend fully\r\n            hip_pitch = math.atan2(hip_z, hip_x)\r\n            knee_angle = 0.0\r\n            ankle_pitch = -hip_pitch\r\n        elif distance < abs(self.thigh_length - self.shin_length):\r\n            # Target too close, this is a problem\r\n            raise ValueError("Target position is not reachable")\r\n        else:\r\n            # Use law of cosines to find knee angle\r\n            cos_knee = (self.thigh_length**2 + self.shin_length**2 - distance**2) / (2 * self.thigh_length * self.shin_length)\r\n            cos_knee = max(-1, min(1, cos_knee))  # Clamp to valid range\r\n            knee_angle = math.pi - math.acos(cos_knee)\r\n\r\n            # Calculate hip pitch angle\r\n            cos_hip = (self.thigh_length**2 + distance**2 - self.shin_length**2) / (2 * self.thigh_length * distance)\r\n            cos_hip = max(-1, min(1, cos_hip))  # Clamp to valid range\r\n            alpha = math.acos(cos_hip)\r\n            beta = math.atan2(hip_z, hip_x)\r\n            hip_pitch = beta - alpha\r\n\r\n            # Calculate ankle angle to maintain foot orientation\r\n            ankle_pitch = -(hip_pitch + (math.pi - knee_angle))\r\n\r\n        return hip_yaw, hip_pitch, ankle_pitch\r\n\r\n    def solve_leg_ik(self, leg_name: str, target_pose: Pose) -> List[float]:\r\n        """\r\n        Solve inverse kinematics for a leg\r\n        Returns joint angles [hip_yaw, hip_pitch, knee, ankle_pitch, ankle_roll]\r\n        """\r\n        # Extract target position relative to hip\r\n        target_x = target_pose.position.x\r\n        target_y = target_pose.position.y\r\n        target_z = target_pose.position.z\r\n\r\n        # Solve for 3-DOF leg\r\n        hip_yaw, hip_pitch, ankle_pitch = self.leg_ik_3dof(target_x, target_y, target_z)\r\n\r\n        # For simplicity, set other angles to 0 (in real implementation, these would be calculated)\r\n        knee_angle = math.pi - (math.pi - (hip_pitch + ankle_pitch))  # Ensure proper knee angle\r\n        ankle_roll = 0.0  # Simplified\r\n\r\n        return [hip_yaw, hip_pitch, knee_angle, ankle_pitch, ankle_roll]\r\n\r\nclass HumanoidLocomotionController(Node):\r\n    """ROS2 node for controlling humanoid locomotion"""\r\n    def __init__(self):\r\n        super().__init__(\'humanoid_locomotion_controller\')\r\n\r\n        # Publishers and subscribers\r\n        self.joint_cmd_pub = self.create_publisher(\r\n            JointState, \'/humanoid/joint_commands\', 10)\r\n        self.target_pose_sub = self.create_subscription(\r\n            Pose, \'/humanoid/target_pose\', self.target_pose_callback, 10)\r\n        self.walk_command_sub = self.create_subscription(\r\n            Float64MultiArray, \'/humanoid/walk_command\', self.walk_command_callback, 10)\r\n\r\n        # Initialize IK solver\r\n        self.ik_solver = HumanoidIKSolver()\r\n\r\n        # Robot state\r\n        self.current_joint_positions = {}\r\n        self.left_foot_target = Pose()\r\n        self.right_foot_target = Pose()\r\n        self.body_pose = Pose()\r\n\r\n        # Walking parameters\r\n        self.step_height = 0.05  # 5cm step height\r\n        self.step_length = 0.3   # 30cm step length\r\n        self.walk_frequency = 1.0  # 1 Hz\r\n\r\n        self.get_logger().info(\'Humanoid Locomotion Controller initialized\')\r\n\r\n    def target_pose_callback(self, msg):\r\n        """Handle target pose for locomotion"""\r\n        # Update target pose for feet\r\n        # This would be more complex in a real implementation\r\n        self.get_logger().info(f\'Target pose received: ({msg.position.x}, {msg.position.y}, {msg.position.z})\')\r\n\r\n    def walk_command_callback(self, msg):\r\n        """Handle walk command with parameters"""\r\n        if len(msg.data) >= 3:\r\n            # Parse walk command: [linear_velocity, angular_velocity, step_height]\r\n            linear_vel = msg.data[0]\r\n            angular_vel = msg.data[1]\r\n            step_height = msg.data[2] if len(msg.data) > 2 else self.step_height\r\n\r\n            # Generate walking pattern based on command\r\n            self.generate_walking_pattern(linear_vel, angular_vel, step_height)\r\n\r\n    def generate_walking_pattern(self, linear_vel: float, angular_vel: float, step_height: float):\r\n        """Generate walking pattern based on velocity commands"""\r\n        # Calculate step parameters based on velocity\r\n        step_length = min(self.step_length, linear_vel / self.walk_frequency)\r\n\r\n        # Generate foot trajectories for walking\r\n        left_foot_traj = self.generate_foot_trajectory(\r\n            \'left\', linear_vel, angular_vel, step_length, step_height)\r\n        right_foot_traj = self.generate_foot_trajectory(\r\n            \'right\', linear_vel, angular_vel, step_length, step_height)\r\n\r\n        # Execute walking pattern\r\n        self.execute_walking_step(left_foot_traj, right_foot_traj)\r\n\r\n    def generate_foot_trajectory(self, foot_name: str, linear_vel: float, angular_vel: float,\r\n                                 step_length: float, step_height: float) -> List[Pose]:\r\n        """Generate foot trajectory for walking"""\r\n        trajectory = []\r\n\r\n        # Simple walking trajectory generation\r\n        # In real implementation, this would be more sophisticated\r\n        num_points = 10  # Number of trajectory points per step\r\n\r\n        for i in range(num_points):\r\n            t = i / (num_points - 1)  # Normalized time (0 to 1)\r\n\r\n            # Calculate position along trajectory\r\n            x = t * step_length\r\n            z = step_height * math.sin(math.pi * t)  # Parabolic trajectory for step height\r\n            y = 0.0  # No lateral movement in this simple example\r\n\r\n            pose = Pose()\r\n            pose.position.x = x\r\n            pose.position.y = y\r\n            pose.position.z = z\r\n\r\n            trajectory.append(pose)\r\n\r\n        return trajectory\r\n\r\n    def execute_walking_step(self, left_trajectory: List[Pose], right_trajectory: List[Pose]):\r\n        """Execute a walking step using the trajectories"""\r\n        # Inverse kinematics for each trajectory point\r\n        for left_pose, right_pose in zip(left_trajectory, right_trajectory):\r\n            # Solve IK for left leg\r\n            try:\r\n                left_angles = self.ik_solver.solve_leg_ik(\'left\', left_pose)\r\n            except ValueError:\r\n                self.get_logger().warn(\'Left leg IK solution not found\')\r\n                continue\r\n\r\n            # Solve IK for right leg\r\n            try:\r\n                right_angles = self.ik_solver.solve_leg_ik(\'right\', right_pose)\r\n            except ValueError:\r\n                self.get_logger().warn(\'Right leg IK solution not found\')\r\n                continue\r\n\r\n            # Publish joint commands\r\n            self.publish_joint_commands(left_angles, right_angles)\r\n\r\n            # Small delay to simulate execution time\r\n            import time\r\n            time.sleep(0.05)\r\n\r\n    def publish_joint_commands(self, left_angles: List[float], right_angles: List[float]):\r\n        """Publish joint commands to robot"""\r\n        joint_state = JointState()\r\n        joint_state.header.stamp = self.get_clock().now().to_msg()\r\n        joint_state.header.frame_id = \'base_link\'\r\n\r\n        # Define joint names (these would match your robot\'s joint names)\r\n        left_joint_names = [\r\n            \'left_hip_yaw\', \'left_hip_pitch\', \'left_knee\',\r\n            \'left_ankle_pitch\', \'left_ankle_roll\'\r\n        ]\r\n        right_joint_names = [\r\n            \'right_hip_yaw\', \'right_hip_pitch\', \'right_knee\',\r\n            \'right_ankle_pitch\', \'right_ankle_roll\'\r\n        ]\r\n\r\n        # Combine joint names and positions\r\n        joint_state.name.extend(left_joint_names)\r\n        joint_state.name.extend(right_joint_names)\r\n        joint_state.position.extend(left_angles)\r\n        joint_state.position.extend(right_angles)\r\n\r\n        # Add velocity and effort commands\r\n        joint_state.velocity.extend([0.0] * len(left_angles))\r\n        joint_state.velocity.extend([0.0] * len(right_angles))\r\n        joint_state.effort.extend([0.0] * len(left_angles))\r\n        joint_state.effort.extend([0.0] * len(right_angles))\r\n\r\n        # Publish joint commands\r\n        self.joint_cmd_pub.publish(joint_state)\r\n\r\n    def calculate_balance_control(self, com_position, com_velocity, zmp_target):\r\n        """Calculate balance control adjustments"""\r\n        # Simple PD controller for balance\r\n        # In real implementation, this would be more sophisticated\r\n        kp = 10.0  # Proportional gain\r\n        kd = 1.0   # Derivative gain\r\n\r\n        com_error = com_position - zmp_target\r\n        control_output = kp * com_error + kd * com_velocity\r\n\r\n        return control_output\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = HumanoidLocomotionController()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Shutting down humanoid locomotion controller...\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-control-for-humanoid-balance",children:"Whole-Body Control for Humanoid Balance"}),"\n",(0,o.jsx)(e.p,{children:"Implementation of whole-body control for maintaining humanoid balance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nWhole-Body Control for Humanoid Balance\r\nDemonstrates whole-body control techniques for maintaining humanoid balance\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState, Imu\r\nfrom geometry_msgs.msg import Point, Vector3\r\nfrom std_msgs.msg import Float64, Bool\r\nimport numpy as np\r\nimport math\r\nfrom typing import Dict, List\r\nimport time\r\nimport asyncio\r\n\r\nclass CenterOfMassEstimator:\r\n    """Estimates center of mass position and velocity"""\r\n    def __init__(self):\r\n        self.com_position = np.array([0.0, 0.0, 0.0])\r\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\r\n        self.com_history = []\r\n        self.max_history = 10\r\n\r\n    def update_com(self, joint_positions: Dict[str, float], joint_velocities: Dict[str, float]):\r\n        """Update center of mass estimation based on joint positions"""\r\n        # Simplified COM calculation - in real implementation, this would use full kinematic model\r\n        # and link masses\r\n        self.com_position = np.array([\r\n            joint_positions.get(\'left_hip_pitch\', 0.0) * 0.1 +\r\n            joint_positions.get(\'right_hip_pitch\', 0.0) * 0.1,\r\n            joint_positions.get(\'left_hip_yaw\', 0.0) * 0.05 +\r\n            joint_positions.get(\'right_hip_yaw\', 0.0) * 0.05,\r\n            0.8  # Fixed height for this example\r\n        ])\r\n\r\n        # Calculate velocity from history\r\n        self.com_history.append(self.com_position.copy())\r\n        if len(self.com_history) > 1:\r\n            dt = 0.01  # 100Hz assumption\r\n            self.com_velocity = (self.com_history[-1] - self.com_history[-2]) / dt\r\n\r\n        # Keep history within limits\r\n        if len(self.com_history) > self.max_history:\r\n            self.com_history.pop(0)\r\n\r\n    def get_com_state(self):\r\n        """Get current COM position and velocity"""\r\n        return self.com_position.copy(), self.com_velocity.copy()\r\n\r\nclass ZeroMomentPointController:\r\n    """Zero Moment Point (ZMP) controller for balance"""\r\n    def __init__(self, com_height=0.8, gravity=9.81):\r\n        self.com_height = com_height\r\n        self.gravity = gravity\r\n        self.zmp_position = np.array([0.0, 0.0])\r\n        self.zmp_reference = np.array([0.0, 0.0])\r\n\r\n    def calculate_zmp(self, com_position, com_acceleration):\r\n        """Calculate ZMP from COM position and acceleration"""\r\n        # ZMP = COM_xy - (COM_height / gravity) * COM_acceleration_xy\r\n        zmp_x = com_position[0] - (self.com_height / self.gravity) * com_acceleration[0]\r\n        zmp_y = com_position[1] - (self.com_height / self.gravity) * com_acceleration[1]\r\n        return np.array([zmp_x, zmp_y])\r\n\r\n    def calculate_com_reference(self, time, omega=1.0):\r\n        """Calculate reference COM trajectory for periodic motion"""\r\n        # Generate periodic reference trajectory\r\n        ref_x = 0.01 * math.sin(omega * time)  # Small oscillation\r\n        ref_y = 0.01 * math.cos(omega * time)\r\n        return np.array([ref_x, ref_y, self.com_height])\r\n\r\n    def balance_control_law(self, current_zmp, reference_zmp, dt=0.01):\r\n        """Simple balance control law"""\r\n        # PD controller for ZMP tracking\r\n        kp = 10.0\r\n        kd = 1.0\r\n\r\n        zmp_error = reference_zmp - current_zmp\r\n        control_output = kp * zmp_error  # Simplified control\r\n\r\n        return control_output\r\n\r\nclass SupportPolygon:\r\n    """Define support polygon for balance"""\r\n    def __init__(self):\r\n        self.left_foot_pos = np.array([0.0, 0.1, 0.0])  # Default positions\r\n        self.right_foot_pos = np.array([0.0, -0.1, 0.0])\r\n        self.support_polygon = self.calculate_support_polygon()\r\n\r\n    def update_foot_positions(self, left_pos, right_pos):\r\n        """Update foot positions and recalculate support polygon"""\r\n        self.left_foot_pos = np.array(left_pos)\r\n        self.right_foot_pos = np.array(right_pos)\r\n        self.support_polygon = self.calculate_support_polygon()\r\n\r\n    def calculate_support_polygon(self):\r\n        """Calculate support polygon from foot positions"""\r\n        # For two feet, support polygon is the convex hull of both feet\r\n        # Simplified as a rectangle for this example\r\n        min_x = min(self.left_foot_pos[0], self.right_foot_pos[0]) - 0.1\r\n        max_x = max(self.left_foot_pos[0], self.right_foot_pos[0]) + 0.1\r\n        min_y = min(self.left_foot_pos[1], self.right_foot_pos[1]) - 0.1\r\n        max_y = max(self.left_foot_pos[1], self.right_foot_pos[1]) + 0.1\r\n\r\n        return {\r\n            \'min_x\': min_x, \'max_x\': max_x,\r\n            \'min_y\': min_y, \'max_y\': max_y\r\n        }\r\n\r\n    def is_stable(self, com_position):\r\n        """Check if COM is within support polygon"""\r\n        return (self.support_polygon[\'min_x\'] <= com_position[0] <= self.support_polygon[\'max_x\'] and\r\n                self.support_polygon[\'min_y\'] <= com_position[1] <= self.support_polygon[\'max_y\'])\r\n\r\nclass WholeBodyController(Node):\r\n    """ROS2 node for whole-body control of humanoid robot"""\r\n    def __init__(self):\r\n        super().__init__(\'whole_body_controller\')\r\n\r\n        # Publishers and subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu/data\', self.imu_callback, 10)\r\n        self.balance_cmd_pub = self.create_publisher(\r\n            JointState, \'/balance_commands\', 10)\r\n        self.com_pub = self.create_publisher(\r\n            Point, \'/center_of_mass\', 10)\r\n        self.zmp_pub = self.create_publisher(\r\n            Point, \'/zero_moment_point\', 10)\r\n        self.balance_status_pub = self.create_publisher(\r\n            Bool, \'/balance_status\', 10)\r\n\r\n        # Initialize controllers\r\n        self.com_estimator = CenterOfMassEstimator()\r\n        self.zmp_controller = ZeroMomentPointController()\r\n        self.support_polygon = SupportPolygon()\r\n\r\n        # Robot state\r\n        self.joint_positions = {}\r\n        self.joint_velocities = {}\r\n        self.imu_data = None\r\n\r\n        # Control parameters\r\n        self.control_dt = 0.01  # 100Hz control\r\n        self.balance_gains = {\'kp\': 50.0, \'kd\': 10.0}\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(self.control_dt, self.balance_control_loop)\r\n\r\n        self.get_logger().info(\'Whole Body Controller initialized\')\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Update joint state information"""\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.joint_positions[name] = msg.position[i]\r\n            if i < len(msg.velocity):\r\n                self.joint_velocities[name] = msg.velocity[i]\r\n\r\n    def imu_callback(self, msg):\r\n        """Update IMU data"""\r\n        self.imu_data = msg\r\n\r\n    def balance_control_loop(self):\r\n        """Main balance control loop"""\r\n        if not self.joint_positions:\r\n            return\r\n\r\n        try:\r\n            # Update COM estimation\r\n            self.com_estimator.update_com(self.joint_positions, self.joint_velocities)\r\n            com_pos, com_vel = self.com_estimator.get_com_state()\r\n\r\n            # Estimate COM acceleration (simplified)\r\n            # In real implementation, this would use more sophisticated estimation\r\n            com_acc = np.array([0.0, 0.0, 0.0])\r\n            if len(self.com_estimator.com_history) > 2:\r\n                dt = self.control_dt\r\n                prev_vel = (self.com_estimator.com_history[-2] - self.com_estimator.com_history[-3]) / dt\r\n                com_acc = (com_vel - prev_vel) / dt\r\n\r\n            # Calculate ZMP\r\n            current_zmp = self.zmp_controller.calculate_zmp(com_pos, com_acc)\r\n\r\n            # Calculate reference ZMP (for this example, try to keep ZMP at origin)\r\n            reference_zmp = np.array([0.0, 0.0])\r\n\r\n            # Update support polygon (simplified - in real implementation, get actual foot positions)\r\n            left_foot_pos = [\r\n                self.joint_positions.get(\'left_ankle_pitch\', 0.0) * 0.05,\r\n                0.1,  # Fixed Y position for left foot\r\n                0.0\r\n            ]\r\n            right_foot_pos = [\r\n                self.joint_positions.get(\'right_ankle_pitch\', 0.0) * 0.05,\r\n                -0.1,  # Fixed Y position for right foot\r\n                0.0\r\n            ]\r\n            self.support_polygon.update_foot_positions(left_foot_pos, right_foot_pos)\r\n\r\n            # Check if robot is stable\r\n            is_stable = self.support_polygon.is_stable(com_pos)\r\n\r\n            # Generate balance control commands\r\n            balance_correction = self.zmp_controller.balance_control_law(\r\n                current_zmp, reference_zmp, self.control_dt)\r\n\r\n            # Apply balance corrections to joint commands\r\n            balance_commands = self.generate_balance_commands(balance_correction, com_pos, com_vel)\r\n\r\n            # Publish results\r\n            self.publish_balance_state(com_pos, current_zmp, is_stable, balance_commands)\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error in balance control: {e}\')\r\n\r\n    def generate_balance_commands(self, balance_correction, com_pos, com_vel):\r\n        """Generate joint commands for balance correction"""\r\n        # This is a simplified balance control\r\n        # In real implementation, this would use whole-body inverse kinematics\r\n        # or other sophisticated control methods\r\n\r\n        commands = JointState()\r\n        commands.header.stamp = self.get_clock().now().to_msg()\r\n        commands.header.frame_id = \'base_link\'\r\n\r\n        # Define joints to control for balance\r\n        balance_joints = [\r\n            \'left_hip_pitch\', \'right_hip_pitch\',\r\n            \'left_ankle_pitch\', \'right_ankle_pitch\',\r\n            \'left_ankle_roll\', \'right_ankle_roll\'\r\n        ]\r\n\r\n        # Calculate balance adjustments based on COM deviation\r\n        hip_pitch_adjust = balance_correction[1] * 0.1  # Y correction affects hip pitch\r\n        ankle_pitch_adjust = -balance_correction[1] * 0.05  # Inverse for ankle\r\n        ankle_roll_adjust = balance_correction[0] * 0.05  # X correction affects roll\r\n\r\n        # Set joint commands\r\n        for joint_name in balance_joints:\r\n            commands.name.append(joint_name)\r\n\r\n            if \'hip_pitch\' in joint_name:\r\n                # Adjust hip pitch based on balance needs\r\n                base_pos = self.joint_positions.get(joint_name, 0.0)\r\n                adjustment = hip_pitch_adjust if \'left\' in joint_name else -hip_pitch_adjust\r\n                commands.position.append(base_pos + adjustment)\r\n            elif \'ankle_pitch\' in joint_name:\r\n                # Adjust ankle pitch for balance\r\n                base_pos = self.joint_positions.get(joint_name, 0.0)\r\n                adjustment = ankle_pitch_adjust if \'left\' in joint_name else -ankle_pitch_adjust\r\n                commands.position.append(base_pos + adjustment)\r\n            elif \'ankle_roll\' in joint_name:\r\n                # Adjust ankle roll for balance\r\n                base_pos = self.joint_positions.get(joint_name, 0.0)\r\n                adjustment = ankle_roll_adjust if \'left\' in joint_name else -ankle_roll_adjust\r\n                commands.position.append(base_pos + adjustment)\r\n            else:\r\n                # Default: maintain current position\r\n                commands.position.append(self.joint_positions.get(joint_name, 0.0))\r\n\r\n            # Add velocity and effort commands\r\n            commands.velocity.append(0.0)  # Target velocity\r\n            commands.effort.append(0.0)    # Target effort\r\n\r\n        return commands\r\n\r\n    def publish_balance_state(self, com_pos, zmp_pos, is_stable, balance_commands):\r\n        """Publish balance state information"""\r\n        # Publish COM position\r\n        com_msg = Point()\r\n        com_msg.x = float(com_pos[0])\r\n        com_msg.y = float(com_pos[1])\r\n        com_msg.z = float(com_pos[2])\r\n        self.com_pub.publish(com_msg)\r\n\r\n        # Publish ZMP position\r\n        zmp_msg = Point()\r\n        zmp_msg.x = float(zmp_pos[0])\r\n        zmp_msg.y = float(zmp_pos[1])\r\n        zmp_msg.z = 0.0  # ZMP is on ground plane\r\n        self.zmp_pub.publish(zmp_msg)\r\n\r\n        # Publish balance status\r\n        status_msg = Bool()\r\n        status_msg.data = is_stable\r\n        self.balance_status_pub.publish(status_msg)\r\n\r\n        # Publish balance commands\r\n        self.balance_cmd_pub.publish(balance_commands)\r\n\r\n        # Log balance information\r\n        self.get_logger().debug(\r\n            f\'COM: ({com_pos[0]:.3f}, {com_pos[1]:.3f}, {com_pos[2]:.3f}), \'\r\n            f\'ZMP: ({zmp_pos[0]:.3f}, {zmp_pos[1]:.3f}), \'\r\n            f\'Stable: {is_stable}\'\r\n        )\r\n\r\ndef main(args=None):\r\n    """Main function to run the whole body control example"""\r\n    rclpy.init(args=args)\r\n    node = WholeBodyController()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Shutting down whole body controller...\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-walking-pattern-generation",children:"Dynamic Walking Pattern Generation"}),"\n",(0,o.jsx)(e.p,{children:"Implementation of dynamic walking pattern generation for humanoid robots:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nDynamic Walking Pattern Generation\r\nDemonstrates dynamic walking pattern generation for humanoid robots\r\n"""\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import Twist, Point\r\nfrom std_msgs.msg import Float64MultiArray, Bool\r\nimport numpy as np\r\nimport math\r\nfrom typing import List, Tuple\r\nimport time\r\n\r\nclass WalkingPatternGenerator:\r\n    """Generate walking patterns for humanoid robots"""\r\n    def __init__(self):\r\n        self.step_length = 0.3  # 30cm step length\r\n        self.step_width = 0.2   # 20cm step width (distance between feet)\r\n        self.step_height = 0.05 # 5cm step height\r\n        self.step_duration = 1.0  # 1 second per step\r\n        self.zmp_offset = 0.02  # ZMP offset for stability\r\n\r\n    def generate_double_support_phase(self, start_pos, end_pos, duration, num_points=10):\r\n        """Generate double support phase trajectory"""\r\n        trajectory = []\r\n        for i in range(num_points):\r\n            t = i / (num_points - 1) if num_points > 1 else 0\r\n            x = start_pos[0] + t * (end_pos[0] - start_pos[0])\r\n            y = start_pos[1] + t * (end_pos[1] - start_pos[1])\r\n            z = start_pos[2] + t * (end_pos[2] - start_pos[2])\r\n            trajectory.append(np.array([x, y, z]))\r\n        return trajectory\r\n\r\n    def generate_single_support_phase(self, start_pos, end_pos, max_height, num_points=20):\r\n        """Generate single support phase with parabolic trajectory"""\r\n        trajectory = []\r\n        for i in range(num_points):\r\n            t = i / (num_points - 1) if num_points > 1 else 0\r\n\r\n            # Linear interpolation for x, y\r\n            x = start_pos[0] + t * (end_pos[0] - start_pos[0])\r\n            y = start_pos[1] + t * (end_pos[1] - start_pos[1])\r\n\r\n            # Parabolic trajectory for z (step height)\r\n            z = start_pos[2] + t * (end_pos[2] - start_pos[2])\r\n            z += max_height * math.sin(math.pi * t)  # Add step height\r\n\r\n            trajectory.append(np.array([x, y, z]))\r\n        return trajectory\r\n\r\n    def generate_walking_trajectory(self, num_steps: int, step_type: str = \'forward\') -> List[np.array]:\r\n        """Generate complete walking trajectory"""\r\n        trajectory = []\r\n\r\n        # Starting positions for feet\r\n        left_foot_pos = np.array([0.0, self.step_width/2, 0.0])\r\n        right_foot_pos = np.array([0.0, -self.step_width/2, 0.0])\r\n\r\n        # Generate steps\r\n        for step in range(num_steps):\r\n            if step % 2 == 0:  # Even steps: move right foot forward\r\n                # Single support: right foot moves forward\r\n                next_right_pos = right_foot_pos + np.array([self.step_length, 0, 0])\r\n                single_support = self.generate_single_support_phase(\r\n                    right_foot_pos, next_right_pos, self.step_height)\r\n                trajectory.extend(single_support)\r\n\r\n                # Update position\r\n                right_foot_pos = next_right_pos\r\n\r\n                # Double support phase\r\n                if step < num_steps - 1:  # Not the last step\r\n                    double_support = self.generate_double_support_phase(\r\n                        left_foot_pos, left_foot_pos, self.step_duration/4)\r\n                    trajectory.extend(double_support)\r\n\r\n            else:  # Odd steps: move left foot forward\r\n                # Single support: left foot moves forward\r\n                next_left_pos = left_foot_pos + np.array([self.step_length, 0, 0])\r\n                single_support = self.generate_single_support_phase(\r\n                    left_foot_pos, next_left_pos, self.step_height)\r\n                trajectory.extend(single_support)\r\n\r\n                # Update position\r\n                left_foot_pos = next_left_pos\r\n\r\n                # Double support phase\r\n                if step < num_steps - 1:  # Not the last step\r\n                    double_support = self.generate_double_support_phase(\r\n                        right_foot_pos, right_foot_pos, self.step_duration/4)\r\n                    trajectory.extend(double_support)\r\n\r\n        return trajectory\r\n\r\n    def generate_com_trajectory(self, foot_trajectory: List[np.array], dt: float = 0.01) -> List[np.array]:\r\n        """Generate Center of Mass trajectory following foot placement"""\r\n        # Simplified COM trajectory generation\r\n        # In real implementation, this would use inverted pendulum or other models\r\n        com_trajectory = []\r\n\r\n        for i, foot_pos in enumerate(foot_trajectory):\r\n            # Follow foot position with slight lag for stability\r\n            if i > 0 and i < len(foot_trajectory) - 1:\r\n                prev_pos = foot_trajectory[i-1]\r\n                next_pos = foot_trajectory[i+1]\r\n                # Smooth following with averaging\r\n                smooth_pos = (prev_pos + foot_pos + next_pos) / 3.0\r\n                com_pos = smooth_pos + np.array([0.0, 0.0, 0.8])  # Add fixed height\r\n            else:\r\n                com_pos = foot_pos + np.array([0.0, 0.0, 0.8])  # Fixed height\r\n\r\n            com_trajectory.append(com_pos)\r\n\r\n        return com_trajectory\r\n\r\nclass DynamicWalkingController(Node):\r\n    """ROS2 node for dynamic walking control"""\r\n    def __init__(self):\r\n        super().__init__(\'dynamic_walking_controller\')\r\n\r\n        # Publishers and subscribers\r\n        self.joint_cmd_pub = self.create_publisher(\r\n            JointState, \'/dynamic_walk_commands\', 10)\r\n        self.walk_cmd_sub = self.create_subscription(\r\n            Twist, \'/cmd_walk\', self.walk_command_callback, 10)\r\n        self.com_trajectory_pub = self.create_publisher(\r\n            Point, \'/com_trajectory\', 10)\r\n        self.foot_trajectory_pub = self.create_publisher(\r\n            Point, \'/foot_trajectory\', 10)\r\n        self.walk_status_pub = self.create_publisher(\r\n            Bool, \'/walking_status\', 10)\r\n\r\n        # Initialize walking components\r\n        self.pattern_generator = WalkingPatternGenerator()\r\n        self.current_trajectory = []\r\n        self.trajectory_index = 0\r\n        self.is_walking = False\r\n\r\n        # Walking parameters\r\n        self.walking_speed = 0.0  # Current walking speed\r\n        self.walking_direction = 0.0  # Turning direction\r\n        self.step_frequency = 1.0  # Steps per second\r\n\r\n        # Timer for walking execution\r\n        self.walk_timer = self.create_timer(0.05, self.walk_execution_callback)  # 20Hz\r\n\r\n        self.get_logger().info(\'Dynamic Walking Controller initialized\')\r\n\r\n    def walk_command_callback(self, msg):\r\n        """Handle walking commands"""\r\n        linear_x = msg.linear.x\r\n        angular_z = msg.angular.z\r\n\r\n        # Update walking parameters\r\n        self.walking_speed = linear_x\r\n        self.walking_direction = angular_z\r\n\r\n        # Generate walking trajectory based on command\r\n        if abs(linear_x) > 0.01 or abs(angular_z) > 0.01:\r\n            self.start_walking()\r\n        else:\r\n            self.stop_walking()\r\n\r\n    def start_walking(self):\r\n        """Start walking with current parameters"""\r\n        if not self.is_walking:\r\n            self.get_logger().info(\'Starting dynamic walking\')\r\n\r\n            # Calculate number of steps based on speed\r\n            num_steps = 10  # Generate 10 steps ahead\r\n\r\n            # Generate walking trajectory\r\n            self.current_trajectory = self.pattern_generator.generate_walking_trajectory(\r\n                num_steps, \'forward\')\r\n\r\n            self.trajectory_index = 0\r\n            self.is_walking = True\r\n\r\n            # Publish walking status\r\n            status_msg = Bool()\r\n            status_msg.data = True\r\n            self.walk_status_pub.publish(status_msg)\r\n\r\n    def stop_walking(self):\r\n        """Stop walking"""\r\n        if self.is_walking:\r\n            self.get_logger().info(\'Stopping dynamic walking\')\r\n            self.is_walking = False\r\n\r\n            # Publish walking status\r\n            status_msg = Bool()\r\n            status_msg.data = False\r\n            self.walk_status_pub.publish(status_msg)\r\n\r\n    def walk_execution_callback(self):\r\n        """Execute walking based on trajectory"""\r\n        if not self.is_walking or not self.current_trajectory:\r\n            return\r\n\r\n        # Check if we need to regenerate trajectory\r\n        if self.trajectory_index >= len(self.current_trajectory):\r\n            # Generate new trajectory\r\n            self.current_trajectory = self.pattern_generator.generate_walking_trajectory(\r\n                10, \'forward\')\r\n            self.trajectory_index = 0\r\n\r\n        # Get current target position from trajectory\r\n        target_pos = self.current_trajectory[self.trajectory_index]\r\n\r\n        # Generate joint commands for target position (simplified)\r\n        joint_commands = self.generate_joint_commands_from_foot_pos(target_pos)\r\n\r\n        # Publish joint commands\r\n        self.joint_cmd_pub.publish(joint_commands)\r\n\r\n        # Publish trajectory information\r\n        self.publish_trajectory_info(target_pos)\r\n\r\n        # Increment trajectory index\r\n        self.trajectory_index += 1\r\n\r\n        # Log walking information\r\n        self.get_logger().debug(\r\n            f\'Walking - Speed: {self.walking_speed:.2f}, \'\r\n            f\'Direction: {self.walking_direction:.2f}, \'\r\n            f\'Traj idx: {self.trajectory_index}/{len(self.current_trajectory)}\'\r\n        )\r\n\r\n    def generate_joint_commands_from_foot_pos(self, foot_pos) -> JointState:\r\n        """Generate joint commands from desired foot position using inverse kinematics"""\r\n        # This is a simplified joint command generation\r\n        # In real implementation, this would use full inverse kinematics\r\n\r\n        joint_state = JointState()\r\n        joint_state.header.stamp = self.get_clock().now().to_msg()\r\n        joint_state.header.frame_id = \'base_link\'\r\n\r\n        # Define joint names for a simple humanoid model\r\n        joint_names = [\r\n            \'left_hip_yaw\', \'left_hip_pitch\', \'left_hip_roll\',\r\n            \'left_knee\', \'left_ankle_pitch\', \'left_ankle_roll\',\r\n            \'right_hip_yaw\', \'right_hip_pitch\', \'right_hip_roll\',\r\n            \'right_knee\', \'right_ankle_pitch\', \'right_ankle_roll\'\r\n        ]\r\n\r\n        # Calculate joint positions based on desired foot position (simplified)\r\n        joint_positions = []\r\n\r\n        for i, name in enumerate(joint_names):\r\n            if \'left\' in name:\r\n                # Left leg - use foot position to determine joint angles\r\n                if \'hip_pitch\' in name:\r\n                    # Hip pitch affects forward/backward position\r\n                    base_angle = 0.0\r\n                    if foot_pos[0] > 0.1:\r\n                        base_angle = -0.1  # Lean back for forward position\r\n                    joint_positions.append(base_angle)\r\n                elif \'knee\' in name:\r\n                    # Knee angle based on desired leg extension\r\n                    base_angle = 0.0\r\n                    if foot_pos[2] > 0.02:  # If foot is raised\r\n                        base_angle = 0.5   # Bend knee\r\n                    joint_positions.append(base_angle)\r\n                elif \'ankle\' in name:\r\n                    # Ankle angle for balance\r\n                    joint_positions.append(foot_pos[1] * 0.5)  # Balance based on Y position\r\n                else:\r\n                    joint_positions.append(0.0)\r\n            else:\r\n                # Right leg - similar to left but mirrored\r\n                if \'hip_pitch\' in name:\r\n                    base_angle = 0.0\r\n                    if foot_pos[0] > 0.1:\r\n                        base_angle = -0.1\r\n                    joint_positions.append(base_angle)\r\n                elif \'knee\' in name:\r\n                    base_angle = 0.0\r\n                    if foot_pos[2] > 0.02:\r\n                        base_angle = 0.5\r\n                    joint_positions.append(base_angle)\r\n                elif \'ankle\' in name:\r\n                    joint_positions.append(-foot_pos[1] * 0.5)  # Mirror left leg\r\n                else:\r\n                    joint_positions.append(0.0)\r\n\r\n        # Set joint state\r\n        joint_state.name = joint_names\r\n        joint_state.position = joint_positions\r\n        joint_state.velocity = [0.0] * len(joint_positions)\r\n        joint_state.effort = [0.0] * len(joint_positions)\r\n\r\n        return joint_state\r\n\r\n    def publish_trajectory_info(self, current_pos):\r\n        """Publish trajectory information for visualization"""\r\n        # Publish foot trajectory point\r\n        foot_msg = Point()\r\n        foot_msg.x = float(current_pos[0])\r\n        foot_msg.y = float(current_pos[1])\r\n        foot_msg.z = float(current_pos[2])\r\n        self.foot_trajectory_pub.publish(foot_msg)\r\n\r\n        # Publish COM trajectory point (simplified)\r\n        com_msg = Point()\r\n        com_msg.x = float(current_pos[0])  # COM roughly follows foot in X\r\n        com_msg.y = 0.0  # COM stays centered in Y\r\n        com_msg.z = 0.8   # COM fixed height\r\n        self.com_trajectory_pub.publish(com_msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = DynamicWalkingController()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Shutting down dynamic walking controller...\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-balance-control-system",children:"Humanoid Balance Control System"}),"\n",(0,o.jsx)(e.p,{children:"Students implement a complete balance control system for a humanoid robot using whole-body control and ZMP-based stability."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Objectives:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement center of mass estimation"}),"\n",(0,o.jsx)(e.li,{children:"Create ZMP-based balance controller"}),"\n",(0,o.jsx)(e.li,{children:"Develop support polygon calculation"}),"\n",(0,o.jsx)(e.li,{children:"Test stability on simulated humanoid"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Required Components:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Humanoid robot model"}),"\n",(0,o.jsx)(e.li,{children:"IMU and joint position sensors"}),"\n",(0,o.jsx)(e.li,{children:"Whole-body control framework"}),"\n",(0,o.jsx)(e.li,{children:"Balance control algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Simulation environment"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Evaluation Criteria:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Balance stability under disturbances"}),"\n",(0,o.jsx)(e.li,{children:"Recovery from perturbations"}),"\n",(0,o.jsx)(e.li,{children:"Smooth motion execution"}),"\n",(0,o.jsx)(e.li,{children:"Computational efficiency"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-walking-gait-generation",children:"Dynamic Walking Gait Generation"}),"\n",(0,o.jsx)(e.p,{children:"Students develop a dynamic walking system that can generate stable gaits for different walking speeds and directions."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Objectives:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement walking pattern generation"}),"\n",(0,o.jsx)(e.li,{children:"Create smooth trajectory interpolation"}),"\n",(0,o.jsx)(e.li,{children:"Develop adaptive gait parameters"}),"\n",(0,o.jsx)(e.li,{children:"Validate walking stability"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Required Components:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Humanoid robot platform"}),"\n",(0,o.jsx)(e.li,{children:"Footstep planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Trajectory generation tools"}),"\n",(0,o.jsx)(e.li,{children:"Balance control system"}),"\n",(0,o.jsx)(e.li,{children:"Motion capture for validation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Evaluation Criteria:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Walking stability and smoothness"}),"\n",(0,o.jsx)(e.li,{children:"Adaptation to different speeds"}),"\n",(0,o.jsx)(e.li,{children:"Energy efficiency"}),"\n",(0,o.jsx)(e.li,{children:"Robustness to disturbances"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-locomotion-learning",children:"Humanoid Locomotion Learning"}),"\n",(0,o.jsx)(e.p,{children:"Students create a learning system that improves humanoid locomotion through experience and human demonstration."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Objectives:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement locomotion learning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Create demonstration recording system"}),"\n",(0,o.jsx)(e.li,{children:"Develop policy improvement methods"}),"\n",(0,o.jsx)(e.li,{children:"Validate learning effectiveness"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Required Components:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Humanoid robot with learning capabilities"}),"\n",(0,o.jsx)(e.li,{children:"Learning algorithm implementation"}),"\n",(0,o.jsx)(e.li,{children:"Performance evaluation tools"}),"\n",(0,o.jsx)(e.li,{children:"Human demonstration interface"}),"\n",(0,o.jsx)(e.li,{children:"Safety monitoring systems"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Evaluation Criteria:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Learning speed and effectiveness"}),"\n",(0,o.jsx)(e.li,{children:"Improvement over time"}),"\n",(0,o.jsx)(e.li,{children:"Generalization to new conditions"}),"\n",(0,o.jsx)(e.li,{children:"Safety and reliability"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Chapter 14 covered humanoid locomotion and control, including inverse kinematics, whole-body control, balance maintenance, and dynamic walking. Students learned to implement control systems for humanoid robots, focusing on stability, efficiency, and human-like movement patterns. The chapter emphasized the importance of balance control, ZMP concepts, and coordinated movement for creating robots that can operate effectively in human environments."}),"\n",(0,o.jsx)(e.h2,{id:"quiz",children:"Quiz"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What does ZMP stand for in humanoid robotics?"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A: Zero Moment Point"}),"\n",(0,o.jsx)(e.li,{children:"B: Zero Motion Position"}),"\n",(0,o.jsx)(e.li,{children:"C: Zed Motor Processor"}),"\n",(0,o.jsx)(e.li,{children:"D: Zone Management Protocol"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Answer: A"})," - ZMP stands for Zero Moment Point, a key concept in humanoid balance control."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What is the primary purpose of inverse kinematics in humanoid robots?"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A: To determine joint angles from end-effector positions"}),"\n",(0,o.jsx)(e.li,{children:"B: To increase robot speed"}),"\n",(0,o.jsx)(e.li,{children:"C: To reduce power consumption"}),"\n",(0,o.jsx)(e.li,{children:"D: To simplify robot design"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Answer: A"})," - Inverse kinematics determines the joint angles needed to achieve desired end-effector positions."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What is the support polygon in humanoid balance?"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A: The area where the robot can move"}),"\n",(0,o.jsx)(e.li,{children:"B: The convex hull of contact points with the ground"}),"\n",(0,o.jsx)(e.li,{children:"C: A type of polygon shape"}),"\n",(0,o.jsx)(e.li,{children:"D: The robot's walking path"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Answer: B"})," - The support polygon is the convex hull of contact points between the robot and ground, defining the stable region."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Why is whole-body control important for humanoid robots?"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A: It reduces manufacturing costs"}),"\n",(0,o.jsx)(e.li,{children:"B: It coordinates all joints for stable and efficient movement"}),"\n",(0,o.jsx)(e.li,{children:"C: It makes robots physically stronger"}),"\n",(0,o.jsx)(e.li,{children:"D: It eliminates the need for programming"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Answer: B"})," - Whole-body control coordinates all joints to achieve stable and efficient movement patterns."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"What does the center of mass (COM) represent in humanoid balance?"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"A: The heaviest part of the robot"}),"\n",(0,o.jsx)(e.li,{children:"B: The average position of all mass in the robot"}),"\n",(0,o.jsx)(e.li,{children:"C: The robot's height"}),"\n",(0,o.jsx)(e.li,{children:"D: The robot's walking speed"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Answer: B"})," - The center of mass represents the average position of all mass in the robot, crucial for balance control."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement multimodal learning systems"}),"\n",(0,o.jsx)(e.li,{children:"Integrate vision, language, and action components"}),"\n",(0,o.jsx)(e.li,{children:"Develop interactive learning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Create human-robot interaction systems"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Basic understanding of Python programming"}),"\n",(0,o.jsx)(e.li,{children:"Fundamentals of linear algebra and calculus"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of robotics concepts"}),"\n",(0,o.jsx)(e.li,{children:"Introduction to machine learning concepts"}),"\n",(0,o.jsx)(e.li,{children:"Completion of Module 0 (Introduction and Foundations)"}),"\n",(0,o.jsx)(e.li,{children:"Completion of Chapter 01 (Physical AI Basics)"}),"\n",(0,o.jsx)(e.li,{children:"Completion of Chapter 03 (ROS2 Nodes, Topics & Services)"}),"\n",(0,o.jsx)(e.li,{children:"Completion of Chapter 16 (Vision-Language-Action Concepts)"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"estimated-duration",children:"Estimated Duration"}),"\n",(0,o.jsx)(e.p,{children:"6 hours"})]})}function _(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var r=t(6540);const o={},i=r.createContext(o);function s(n){const e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);