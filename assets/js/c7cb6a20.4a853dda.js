"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[95],{4230:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"04-Chapter-4-ROS2-Nodes-Topics-Services","title":"Chapter 4: ROS2 Nodes, Topics, and Services","description":"Overview","source":"@site/docusaurus/docs/04-Chapter-4-ROS2-Nodes-Topics-Services.md","sourceDirName":".","slug":"/04-Chapter-4-ROS2-Nodes-Topics-Services","permalink":"/physical-ai-book/docs/04-Chapter-4-ROS2-Nodes-Topics-Services","draft":false,"unlisted":false,"editUrl":"https://github.com/ayesha-muttalib123/physical-ai-book/tree/main/docusaurus/docs/04-Chapter-4-ROS2-Nodes-Topics-Services.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"04-Chapter-4-ROS2-Nodes-Topics-Services","title":"Chapter 4: ROS2 Nodes, Topics, and Services","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Sensing and Embodied Intelligence","permalink":"/physical-ai-book/docs/03-Chapter-3-Sensing-And-Embodied-Intelligence"},"next":{"title":"Chapter 1: ROS2 Communication Patterns","permalink":"/physical-ai-book/docs/05-Chapter-1-ROS2-Communication-Patterns"}}');var i=s(4848),t=s(8453);const o={id:"04-Chapter-4-ROS2-Nodes-Topics-Services",title:"Chapter 4: ROS2 Nodes, Topics, and Services",sidebar_position:4},a="Chapter 4: ROS2 Nodes, Topics, and Services",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Why It Matters",id:"why-it-matters",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"ROS2 Nodes",id:"ros2-nodes",level:3},{value:"Topics",id:"topics",level:3},{value:"Services",id:"services",level:3},{value:"ROS2 Client Libraries (RCL)",id:"ros2-client-libraries-rcl",level:3},{value:"DDS (Data Distribution Service)",id:"dds-data-distribution-service",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Quality of Service (QoS) Profiles",id:"quality-of-service-qos-profiles",level:3},{value:"Names and Namespaces",id:"names-and-namespaces",level:3},{value:"Code Examples",id:"code-examples",level:2},{value:"ROS2 Publisher Node",id:"ros2-publisher-node",level:3},{value:"ROS2 Subscriber Node",id:"ros2-subscriber-node",level:3},{value:"ROS2 Service Server and Client",id:"ros2-service-server-and-client",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Multi-Robot Communication System",id:"multi-robot-communication-system",level:3},{value:"Sensor Fusion Node",id:"sensor-fusion-node",level:3},{value:"Robot Control Service",id:"robot-control-service",level:3},{value:"Summary",id:"summary",level:2},{value:"Quiz",id:"quiz",level:2},{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Estimated Duration",id:"estimated-duration",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-4-ros2-nodes-topics-and-services",children:"Chapter 4: ROS2 Nodes, Topics, and Services"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"This chapter delves into the fundamental communication mechanisms in ROS2, focusing on nodes, topics, and services. Students will learn how to create ROS2 nodes, implement publisher-subscriber communication patterns, and design service-based interactions. The chapter covers the ROS2 architecture principles, lifecycle management, and best practices for designing robust communication systems in robotic applications."}),"\n",(0,i.jsx)(n.h2,{id:"why-it-matters",children:"Why It Matters"}),"\n",(0,i.jsx)(n.p,{children:"Understanding ROS2 communication primitives is essential for building distributed robotic systems. Nodes, topics, and services form the backbone of ROS2 architecture, enabling modular, scalable, and maintainable robot software. Mastering these concepts allows developers to create complex systems where different components can communicate efficiently and reliably, forming the 'nervous system' of the robot."}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"ros2-nodes",children:"ROS2 Nodes"}),"\n",(0,i.jsx)(n.p,{children:"Independent processes that perform computation and communicate with other nodes. A node is the fundamental building block of a ROS2 system, containing the business logic for a specific function. Each node runs in its own process and can communicate with other nodes through topics, services, actions, and parameters."}),"\n",(0,i.jsx)(n.h3,{id:"topics",children:"Topics"}),"\n",(0,i.jsx)(n.p,{children:"Asynchronous, many-to-many communication channels using publisher-subscriber pattern. Topics allow nodes to send and receive data in a decoupled manner. Publishers send messages to a topic, and any number of subscribers can receive those messages without knowing about each other."}),"\n",(0,i.jsx)(n.h3,{id:"services",children:"Services"}),"\n",(0,i.jsx)(n.p,{children:"Synchronous, request-response communication for direct interaction between nodes. Services provide a way for nodes to request specific actions or information from other nodes, similar to a traditional client-server model."}),"\n",(0,i.jsx)(n.h3,{id:"ros2-client-libraries-rcl",children:"ROS2 Client Libraries (RCL)"}),"\n",(0,i.jsx)(n.p,{children:"Language-specific libraries that provide ROS2 functionality. These libraries (like rclpy for Python and rclcpp for C++) provide the interface between your application code and the ROS2 middleware."}),"\n",(0,i.jsx)(n.h3,{id:"dds-data-distribution-service",children:"DDS (Data Distribution Service)"}),"\n",(0,i.jsx)(n.p,{children:"Middleware that enables communication between ROS2 nodes. DDS is the underlying communication standard that ROS2 uses to manage data distribution between nodes, providing features like discovery, reliability, and quality of service."}),"\n",(0,i.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"The states and transitions that govern node behavior. ROS2 nodes can transition through various states (unconfigured, inactive, active, finalized) allowing for more sophisticated management of resources and behavior."}),"\n",(0,i.jsx)(n.h3,{id:"quality-of-service-qos-profiles",children:"Quality of Service (QoS) Profiles"}),"\n",(0,i.jsx)(n.p,{children:"Configuration parameters that define communication behavior. QoS profiles allow you to specify how messages should be handled in terms of reliability, durability, history, and other characteristics."}),"\n",(0,i.jsx)(n.h3,{id:"names-and-namespaces",children:"Names and Namespaces"}),"\n",(0,i.jsx)(n.p,{children:"Hierarchical naming system for ROS2 entities. Namespaces provide a way to organize ROS2 entities and avoid naming conflicts, similar to directories in a file system."}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.h3,{id:"ros2-publisher-node",children:"ROS2 Publisher Node"}),"\n",(0,i.jsx)(n.p,{children:"Node that publishes sensor data to a topic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom sensor_msgs.msg import LaserScan\r\nimport random\r\n\r\nclass SensorPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_publisher')\r\n\r\n        # Create publisher for sensor data\r\n        self.publisher = self.create_publisher(LaserScan, 'sensor_scan', 10)\r\n\r\n        # Create publisher for status\r\n        self.status_publisher = self.create_publisher(String, 'status', 10)\r\n\r\n        # Create timer to publish data at 10Hz\r\n        self.timer = self.create_timer(0.1, self.publish_scan_data)\r\n\r\n        self.get_logger().info('Sensor publisher node initialized')\r\n\r\n    def publish_scan_data(self):\r\n        # Create and populate LaserScan message\r\n        scan_msg = LaserScan()\r\n        scan_msg.header.stamp = self.get_clock().now().to_msg()\r\n        scan_msg.header.frame_id = 'laser_frame'\r\n\r\n        # Set scan parameters\r\n        scan_msg.angle_min = -1.57  # -90 degrees\r\n        scan_msg.angle_max = 1.57   # 90 degrees\r\n        scan_msg.angle_increment = 0.0174  # 1 degree\r\n\r\n        # Generate sample ranges (simulated sensor data)\r\n        num_ranges = int((scan_msg.angle_max - scan_msg.angle_min) / scan_msg.angle_increment)\r\n        scan_msg.ranges = [random.uniform(0.1, 10.0) for _ in range(num_ranges)]\r\n\r\n        # Publish the scan data\r\n        self.publisher.publish(scan_msg)\r\n\r\n        # Publish status message\r\n        status_msg = String()\r\n        status_msg.data = f'Published scan with {len(scan_msg.ranges)} ranges'\r\n        self.status_publisher.publish(status_msg)\r\n\r\n        self.get_logger().info(f'Published scan data: {status_msg.data}')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    sensor_publisher = SensorPublisher()\r\n\r\n    try:\r\n        rclpy.spin(sensor_publisher)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        sensor_publisher.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ros2-subscriber-node",children:"ROS2 Subscriber Node"}),"\n",(0,i.jsx)(n.p,{children:"Node that subscribes to sensor data and processes it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom std_msgs.msg import Float32\r\nimport numpy as np\r\n\r\nclass SensorSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_subscriber')\r\n\r\n        # Create subscription to sensor data\r\n        self.subscription = self.create_subscription(\r\n            LaserScan,\r\n            'sensor_scan',\r\n            self.scan_callback,\r\n            10\r\n        )\r\n\r\n        # Create publisher for processed data\r\n        self.min_distance_publisher = self.create_publisher(Float32, 'min_distance', 10)\r\n        self.obstacle_warning_publisher = self.create_publisher(String, 'obstacle_warning', 10)\r\n\r\n        self.get_logger().info('Sensor subscriber node initialized')\r\n\r\n    def scan_callback(self, msg):\r\n        # Process the scan data\r\n        if len(msg.ranges) > 0:\r\n            # Filter out invalid ranges (inf, nan)\r\n            valid_ranges = [r for r in msg.ranges if not (r == float('inf') or r == float('nan'))]\r\n\r\n            if valid_ranges:\r\n                min_distance = min(valid_ranges)\r\n                max_distance = max(valid_ranges)\r\n\r\n                # Publish minimum distance\r\n                min_dist_msg = Float32()\r\n                min_dist_msg.data = min_distance\r\n                self.min_distance_publisher.publish(min_dist_msg)\r\n\r\n                # Check for obstacles\r\n                if min_distance < 1.0:  # Obstacle within 1 meter\r\n                    from std_msgs.msg import String\r\n                    warning_msg = String()\r\n                    warning_msg.data = f'OBSTACLE DETECTED: {min_distance:.2f}m'\r\n                    self.obstacle_warning_publisher.publish(warning_msg)\r\n                    self.get_logger().warn(f'Obstacle detected: {min_distance:.2f}m')\r\n                else:\r\n                    self.get_logger().info(f'Min distance: {min_distance:.2f}m, Max distance: {max_distance:.2f}m')\r\n            else:\r\n                self.get_logger().warn('No valid ranges in scan data')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    sensor_subscriber = SensorSubscriber()\r\n\r\n    try:\r\n        rclpy.spin(sensor_subscriber)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        sensor_subscriber.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ros2-service-server-and-client",children:"ROS2 Service Server and Client"}),"\n",(0,i.jsx)(n.p,{children:"Service for controlling robot movement with request-response pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Service definition file (srv/MovementControl.srv):\r\n# float64 linear_velocity\r\n# float64 angular_velocity\r\n# ---\r\n# bool success\r\n# string message\r\n\r\n# Service Server\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.srv import Trigger  # Using Trigger as simple example\r\nfrom std_msgs.msg import String\r\n\r\nclass MovementControlService(Node):\r\n    def __init__(self):\r\n        super().__init__('movement_control_service')\r\n\r\n        # Create service\r\n        self.srv = self.create_service(\r\n            Trigger,  # In practice, use custom service type\r\n            'move_robot',\r\n            self.move_robot_callback\r\n        )\r\n\r\n        # Publisher for movement commands\r\n        self.cmd_publisher = self.create_publisher(String, 'robot_commands', 10)\r\n\r\n        self.get_logger().info('Movement control service ready')\r\n\r\n    def move_robot_callback(self, request, response):\r\n        # In a real implementation, this would process movement commands\r\n        # For this example, we'll just simulate movement\r\n        self.get_logger().info('Received movement request')\r\n\r\n        # Publish movement command\r\n        cmd_msg = String()\r\n        cmd_msg.data = 'move_forward_1m'\r\n        self.cmd_publisher.publish(cmd_msg)\r\n\r\n        # Set response\r\n        response.success = True\r\n        response.message = 'Movement command executed successfully'\r\n\r\n        return response\r\n\r\n# Service Client\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.srv import Trigger\r\nimport time\r\n\r\nclass MovementClient(Node):\r\n    def __init__(self):\r\n        super().__init__('movement_client')\r\n        self.cli = self.create_client(Trigger, 'move_robot')\r\n\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('Service not available, waiting again...')\r\n\r\n        self.req = Trigger.Request()\r\n\r\n    def send_request(self):\r\n        self.future = self.cli.call_async(self.req)\r\n        rclpy.spin_until_future_complete(self, self.future)\r\n        return self.future.result()\r\n\r\ndef main_server(args=None):\r\n    rclpy.init(args=args)\r\n    service = MovementControlService()\r\n\r\n    try:\r\n        rclpy.spin(service)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        service.destroy_node()\r\n        rclpy.shutdown()\r\n\r\ndef main_client(args=None):\r\n    rclpy.init(args=args)\r\n    client = MovementClient()\r\n\r\n    response = client.send_request()\r\n    if response:\r\n        print(f'Response: {response.success}, {response.message}')\r\n    else:\r\n        print('Service call failed')\r\n\r\n    client.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(n.h3,{id:"multi-robot-communication-system",children:"Multi-Robot Communication System"}),"\n",(0,i.jsx)(n.p,{children:"Students implement a system where multiple robots communicate using ROS2 topics and services to coordinate their movements and share sensor data."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design ROS2 nodes for multi-robot communication"}),"\n",(0,i.jsx)(n.li,{children:"Implement publisher-subscriber patterns for sensor sharing"}),"\n",(0,i.jsx)(n.li,{children:"Create services for coordination requests"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple simulated robots"}),"\n",(0,i.jsx)(n.li,{children:"ROS2 network configuration"}),"\n",(0,i.jsx)(n.li,{children:"Communication protocols"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Successful inter-robot communication"}),"\n",(0,i.jsx)(n.li,{children:"Efficient data sharing"}),"\n",(0,i.jsx)(n.li,{children:"Coordination effectiveness"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"sensor-fusion-node",children:"Sensor Fusion Node"}),"\n",(0,i.jsx)(n.p,{children:"Students create a ROS2 node that subscribes to multiple sensor topics and publishes fused sensor data."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement multiple subscribers in one node"}),"\n",(0,i.jsx)(n.li,{children:"Synchronize data from different sensors"}),"\n",(0,i.jsx)(n.li,{children:"Publish processed/fused data"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple sensor topics"}),"\n",(0,i.jsx)(n.li,{children:"Synchronization algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Fusion algorithms"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Correct data synchronization"}),"\n",(0,i.jsx)(n.li,{children:"Effective sensor fusion"}),"\n",(0,i.jsx)(n.li,{children:"Robust node implementation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"robot-control-service",children:"Robot Control Service"}),"\n",(0,i.jsx)(n.p,{children:"Students develop a service-based system for remote robot control with safety checks."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Objectives:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement a ROS2 service for robot control"}),"\n",(0,i.jsx)(n.li,{children:"Add safety validation to service responses"}),"\n",(0,i.jsx)(n.li,{children:"Create client nodes to call the service"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Required Components:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Robot simulation"}),"\n",(0,i.jsx)(n.li,{children:"Safety validation logic"}),"\n",(0,i.jsx)(n.li,{children:"Client-server communication"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Evaluation Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Secure service implementation"}),"\n",(0,i.jsx)(n.li,{children:"Effective safety checks"}),"\n",(0,i.jsx)(n.li,{children:"Reliable communication"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Chapter 3 covers the fundamental ROS2 communication mechanisms: nodes, topics, and services. Students learned how to create ROS2 nodes, implement publisher-subscriber patterns, and design service-based interactions. Through practical examples, they gained experience with multi-robot communication, sensor fusion, and service-based control systems. These concepts form the backbone of ROS2 architecture and are essential for building distributed robotic systems."}),"\n",(0,i.jsx)(n.h2,{id:"quiz",children:"Quiz"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is the main difference between ROS2 topics and services?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A: Topics are for hardware, services are for software"}),"\n",(0,i.jsx)(n.li,{children:"B: Topics are asynchronous many-to-many, services are synchronous request-response"}),"\n",(0,i.jsx)(n.li,{children:"C: Topics are faster than services"}),"\n",(0,i.jsx)(n.li,{children:"D: There is no difference between topics and services"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Answer: B"})," - Topics use an asynchronous, many-to-many communication pattern (publisher-subscriber), while services use a synchronous, request-response pattern between client and server."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is a ROS2 node?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A: A type of robot hardware"}),"\n",(0,i.jsx)(n.li,{children:"B: An independent process that performs computation and communicates with other nodes"}),"\n",(0,i.jsx)(n.li,{children:"C: A configuration file for ROS2"}),"\n",(0,i.jsx)(n.li,{children:"D: A special type of message"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Answer: B"})," - A ROS2 node is an independent process that performs computation and communicates with other nodes through topics, services, actions, and parameters."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What does DDS stand for in the context of ROS2?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A: Distributed Data System"}),"\n",(0,i.jsx)(n.li,{children:"B: Data Distribution Service"}),"\n",(0,i.jsx)(n.li,{children:"C: Dynamic Discovery System"}),"\n",(0,i.jsx)(n.li,{children:"D: Distributed Deployment Service"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Answer: B"})," - DDS stands for Data Distribution Service, which is the middleware that enables communication between ROS2 nodes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is Quality of Service (QoS) in ROS2?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A: A measure of code quality"}),"\n",(0,i.jsx)(n.li,{children:"B: Configuration parameters that define communication behavior"}),"\n",(0,i.jsx)(n.li,{children:"C: A debugging tool"}),"\n",(0,i.jsx)(n.li,{children:"D: A type of ROS2 message"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Answer: B"})," - Quality of Service (QoS) profiles are configuration parameters that define communication behavior such as reliability, durability, and history for topics and services."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What is the purpose of namespaces in ROS2?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A: To organize files on disk"}),"\n",(0,i.jsx)(n.li,{children:"B: To provide hierarchical naming for ROS2 entities to avoid naming conflicts"}),"\n",(0,i.jsx)(n.li,{children:"C: To improve performance"}),"\n",(0,i.jsx)(n.li,{children:"D: To encrypt messages"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Answer: B"})," - Namespaces provide a hierarchical naming system for ROS2 entities to organize them and avoid naming conflicts between different nodes and topics."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, students will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design ROS2 architectures for robot systems"}),"\n",(0,i.jsx)(n.li,{children:"Implement nodes, topics, services, and actions"}),"\n",(0,i.jsx)(n.li,{children:"Manage parameters and configurations"}),"\n",(0,i.jsx)(n.li,{children:"Develop ROS2 packages for multi-robot systems"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Basic understanding of Python programming"}),"\n",(0,i.jsx)(n.li,{children:"Fundamentals of linear algebra and calculus"}),"\n",(0,i.jsx)(n.li,{children:"Basic knowledge of robotics concepts"}),"\n",(0,i.jsx)(n.li,{children:"Introduction to machine learning concepts"}),"\n",(0,i.jsx)(n.li,{children:"Completion of Module 0 (Introduction and Foundations)"}),"\n",(0,i.jsx)(n.li,{children:"Completion of Chapter 01 (Physical AI Basics)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"estimated-duration",children:"Estimated Duration"}),"\n",(0,i.jsx)(n.p,{children:"6 hours"})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);