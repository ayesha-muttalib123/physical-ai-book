---
chapter_id: "17-humanoid-locomotion-control"
title: "Humanoid Locomotion & Control"
module_id: "M5-vla-humanoids"
module_title: "Vision-Language-Action & Humanoids"
overview: "This chapter explores the complex field of humanoid locomotion and control, covering the biomechanics of human-like movement, balance control, and gait generation. Students will learn about various approaches to humanoid locomotion including inverse kinematics, whole-body control, and dynamic balance maintenance. The chapter covers both theoretical foundations and practical implementation of control systems for humanoid robots, with emphasis on stability, efficiency, and human-like movement patterns."
why_it_matters: "Humanoid locomotion and control are fundamental to creating robots that can operate in human environments and interact naturally with human-designed infrastructure. Understanding these concepts is crucial for developing robots that can walk, balance, and move like humans, enabling them to navigate stairs, doors, and other human-centric environments. The principles learned in this chapter are essential for creating safe, stable, and efficient humanoid robots."
key_concepts:
  - "Inverse Kinematics: Mathematical methods for determining joint angles from end-effector positions"
  - "Whole-Body Control: Coordinated control of all robot joints for stable movement"
  - "Balance Control: Techniques for maintaining center of mass within support polygon"
  - "Gait Generation: Algorithms for creating stable walking patterns"
  - "Dynamic Walking: Control strategies for stable dynamic locomotion"
  - "Zero Moment Point (ZMP): Concept for maintaining dynamic balance"
  - "Center of Mass Control: Managing robot's center of mass for stability"
  - "Feedback Control: Using sensor feedback for stable locomotion"

code_examples:
  -
    title: "Inverse Kinematics for Humanoid Legs"
    description: "Implementation of inverse kinematics for controlling humanoid leg movements"
    language: "python"
    framework: "ROS2 with Robotics Libraries"
    code: |
      #!/usr/bin/env python3
      """
      Inverse Kinematics for Humanoid Legs
      Demonstrates inverse kinematics for controlling humanoid leg movements
      """
      import rclpy
      from rclpy.node import Node
      from sensor_msgs.msg import JointState
      from geometry_msgs.msg import Point, Pose
      from std_msgs.msg import Float64MultiArray
      import numpy as np
      import math
      from typing import List, Tuple

      class HumanoidIKSolver:
          """Inverse kinematics solver for humanoid leg"""
          def __init__(self, hip_offset=0.1, thigh_length=0.4, shin_length=0.4, foot_length=0.1):
              self.hip_offset = hip_offset      # Distance from body to hip joint
              self.thigh_length = thigh_length  # Length of thigh
              self.shin_length = shin_length    # Length of shin
              self.foot_length = foot_length    # Length of foot

          def leg_ik_3dof(self, target_x, target_y, target_z) -> Tuple[float, float, float]:
              """
              Solve 3-DOF leg inverse kinematics (hip, knee, ankle)
              Returns: (hip_angle, knee_angle, ankle_angle)
              """
              # Calculate hip angle (yaw) - this is simplified
              hip_yaw = math.atan2(target_y, target_x)

              # Project target onto sagittal plane (XZ plane)
              target_distance = math.sqrt(target_x**2 + target_y**2)
              hip_x = target_distance - self.hip_offset
              hip_z = target_z

              # Calculate distance from hip to target in sagittal plane
              distance = math.sqrt(hip_x**2 + hip_z**2)

              # Check if target is reachable
              if distance > self.thigh_length + self.shin_length:
                  # Target too far, extend fully
                  hip_pitch = math.atan2(hip_z, hip_x)
                  knee_angle = 0.0
                  ankle_pitch = -hip_pitch
              elif distance < abs(self.thigh_length - self.shin_length):
                  # Target too close, this is a problem
                  raise ValueError("Target position is not reachable")
              else:
                  # Use law of cosines to find knee angle
                  cos_knee = (self.thigh_length**2 + self.shin_length**2 - distance**2) / (2 * self.thigh_length * self.shin_length)
                  cos_knee = max(-1, min(1, cos_knee))  # Clamp to valid range
                  knee_angle = math.pi - math.acos(cos_knee)

                  # Calculate hip pitch angle
                  cos_hip = (self.thigh_length**2 + distance**2 - self.shin_length**2) / (2 * self.thigh_length * distance)
                  cos_hip = max(-1, min(1, cos_hip))  # Clamp to valid range
                  alpha = math.acos(cos_hip)
                  beta = math.atan2(hip_z, hip_x)
                  hip_pitch = beta - alpha

                  # Calculate ankle angle to maintain foot orientation
                  ankle_pitch = -(hip_pitch + (math.pi - knee_angle))

              return hip_yaw, hip_pitch, ankle_pitch

          def solve_leg_ik(self, leg_name: str, target_pose: Pose) -> List[float]:
              """
              Solve inverse kinematics for a leg
              Returns joint angles [hip_yaw, hip_pitch, knee, ankle_pitch, ankle_roll]
              """
              # Extract target position relative to hip
              target_x = target_pose.position.x
              target_y = target_pose.position.y
              target_z = target_pose.position.z

              # Solve for 3-DOF leg
              hip_yaw, hip_pitch, ankle_pitch = self.leg_ik_3dof(target_x, target_y, target_z)

              # For simplicity, set other angles to 0 (in real implementation, these would be calculated)
              knee_angle = math.pi - (math.pi - (hip_pitch + ankle_pitch))  # Ensure proper knee angle
              ankle_roll = 0.0  # Simplified

              return [hip_yaw, hip_pitch, knee_angle, ankle_pitch, ankle_roll]

      class HumanoidLocomotionController(Node):
          """ROS2 node for controlling humanoid locomotion"""
          def __init__(self):
              super().__init__('humanoid_locomotion_controller')

              # Publishers and subscribers
              self.joint_cmd_pub = self.create_publisher(
                  JointState, '/humanoid/joint_commands', 10)
              self.target_pose_sub = self.create_subscription(
                  Pose, '/humanoid/target_pose', self.target_pose_callback, 10)
              self.walk_command_sub = self.create_subscription(
                  Float64MultiArray, '/humanoid/walk_command', self.walk_command_callback, 10)

              # Initialize IK solver
              self.ik_solver = HumanoidIKSolver()

              # Robot state
              self.current_joint_positions = {}
              self.left_foot_target = Pose()
              self.right_foot_target = Pose()
              self.body_pose = Pose()

              # Walking parameters
              self.step_height = 0.05  # 5cm step height
              self.step_length = 0.3   # 30cm step length
              self.walk_frequency = 1.0  # 1 Hz

              self.get_logger().info('Humanoid Locomotion Controller initialized')

          def target_pose_callback(self, msg):
              """Handle target pose for locomotion"""
              # Update target pose for feet
              # This would be more complex in a real implementation
              self.get_logger().info(f'Target pose received: ({msg.position.x}, {msg.position.y}, {msg.position.z})')

          def walk_command_callback(self, msg):
              """Handle walk command with parameters"""
              if len(msg.data) >= 3:
                  # Parse walk command: [linear_velocity, angular_velocity, step_height]
                  linear_vel = msg.data[0]
                  angular_vel = msg.data[1]
                  step_height = msg.data[2] if len(msg.data) > 2 else self.step_height

                  # Generate walking pattern based on command
                  self.generate_walking_pattern(linear_vel, angular_vel, step_height)

          def generate_walking_pattern(self, linear_vel: float, angular_vel: float, step_height: float):
              """Generate walking pattern based on velocity commands"""
              # Calculate step parameters based on velocity
              step_length = min(self.step_length, linear_vel / self.walk_frequency)

              # Generate foot trajectories for walking
              left_foot_traj = self.generate_foot_trajectory(
                  'left', linear_vel, angular_vel, step_length, step_height)
              right_foot_traj = self.generate_foot_trajectory(
                  'right', linear_vel, angular_vel, step_length, step_height)

              # Execute walking pattern
              self.execute_walking_step(left_foot_traj, right_foot_traj)

          def generate_foot_trajectory(self, foot_name: str, linear_vel: float, angular_vel: float,
                                     step_length: float, step_height: float) -> List[Pose]:
              """Generate foot trajectory for walking"""
              trajectory = []

              # Simple walking trajectory generation
              # In real implementation, this would be more sophisticated
              num_points = 10  # Number of trajectory points per step

              for i in range(num_points):
                  t = i / (num_points - 1)  # Normalized time (0 to 1)

                  # Calculate position along trajectory
                  x = t * step_length
                  z = step_height * math.sin(math.pi * t)  # Parabolic trajectory for step height
                  y = 0.0  # No lateral movement in this simple example

                  pose = Pose()
                  pose.position.x = x
                  pose.position.y = y
                  pose.position.z = z

                  trajectory.append(pose)

              return trajectory

          def execute_walking_step(self, left_trajectory: List[Pose], right_trajectory: List[Pose]):
              """Execute a walking step using the trajectories"""
              # Inverse kinematics for each trajectory point
              for left_pose, right_pose in zip(left_trajectory, right_trajectory):
                  # Solve IK for left leg
                  try:
                      left_angles = self.ik_solver.solve_leg_ik('left', left_pose)
                  except ValueError:
                      self.get_logger().warn('Left leg IK solution not found')
                      continue

                  # Solve IK for right leg
                  try:
                      right_angles = self.ik_solver.solve_leg_ik('right', right_pose)
                  except ValueError:
                      self.get_logger().warn('Right leg IK solution not found')
                      continue

                  # Publish joint commands
                  self.publish_joint_commands(left_angles, right_angles)

                  # Small delay to simulate execution time
                  import time
                  time.sleep(0.05)

          def publish_joint_commands(self, left_angles: List[float], right_angles: List[float]):
              """Publish joint commands to robot"""
              joint_state = JointState()
              joint_state.header.stamp = self.get_clock().now().to_msg()
              joint_state.header.frame_id = 'base_link'

              # Define joint names (these would match your robot's joint names)
              left_joint_names = [
                  'left_hip_yaw', 'left_hip_pitch', 'left_knee',
                  'left_ankle_pitch', 'left_ankle_roll'
              ]
              right_joint_names = [
                  'right_hip_yaw', 'right_hip_pitch', 'right_knee',
                  'right_ankle_pitch', 'right_ankle_roll'
              ]

              # Combine joint names and positions
              joint_state.name.extend(left_joint_names)
              joint_state.name.extend(right_joint_names)
              joint_state.position.extend(left_angles)
              joint_state.position.extend(right_angles)

              # Publish joint commands
              self.joint_cmd_pub.publish(joint_state)

          def calculate_balance_control(self, com_position, com_velocity, zmp_target):
              """Calculate balance control adjustments"""
              # Simple PD controller for balance
              # In real implementation, this would be more sophisticated
              kp = 10.0  # Proportional gain
              kd = 1.0   # Derivative gain

              com_error = com_position - zmp_target
              control_output = kp * com_error + kd * com_velocity

              return control_output

      def main(args=None):
          rclpy.init(args=args)
          node = HumanoidLocomotionController()

          try:
              rclpy.spin(node)
          except KeyboardInterrupt:
              node.get_logger().info('Shutting down humanoid locomotion controller...')
          finally:
              node.destroy_node()
              rclpy.shutdown()

      if __name__ == '__main__':
          main()

  -
    title: "Whole-Body Control for Humanoid Balance"
    description: "Implementation of whole-body control for maintaining humanoid balance"
    language: "python"
    framework: "ROS2 with Control Libraries"
    code: |
      #!/usr/bin/env python3
      """
      Whole-Body Control for Humanoid Balance
      Demonstrates whole-body control techniques for maintaining humanoid balance
      """
      import rclpy
      from rclpy.node import Node
      from sensor_msgs.msg import JointState, Imu
      from geometry_msgs.msg import Point, Vector3
      from std_msgs.msg import Float64, Bool
      import numpy as np
      import math
      from typing import Dict, List
      import time

      class CenterOfMassEstimator:
          """Estimates center of mass position and velocity"""
          def __init__(self):
              self.com_position = np.array([0.0, 0.0, 0.0])
              self.com_velocity = np.array([0.0, 0.0, 0.0])
              self.com_history = []
              self.max_history = 10

          def update_com(self, joint_positions: Dict[str, float], joint_velocities: Dict[str, float]):
              """Update center of mass estimation based on joint positions"""
              # Simplified COM calculation - in real implementation, this would use full kinematic model
              # and link masses
              self.com_position = np.array([
                  joint_positions.get('left_hip_pitch', 0.0) * 0.1 +
                  joint_positions.get('right_hip_pitch', 0.0) * 0.1,
                  joint_positions.get('left_hip_yaw', 0.0) * 0.05 +
                  joint_positions.get('right_hip_yaw', 0.0) * 0.05,
                  0.8  # Fixed height for this example
              ])

              # Calculate velocity from history
              self.com_history.append(self.com_position.copy())
              if len(self.com_history) > 1:
                  dt = 0.01  # 100Hz assumption
                  self.com_velocity = (self.com_history[-1] - self.com_history[-2]) / dt

              # Keep history within limits
              if len(self.com_history) > self.max_history:
                  self.com_history.pop(0)

          def get_com_state(self):
              """Get current COM position and velocity"""
              return self.com_position.copy(), self.com_velocity.copy()

      class ZeroMomentPointController:
          """Zero Moment Point (ZMP) controller for balance"""
          def __init__(self, com_height=0.8, gravity=9.81):
              self.com_height = com_height
              self.gravity = gravity
              self.zmp_position = np.array([0.0, 0.0])
              self.zmp_reference = np.array([0.0, 0.0])

          def calculate_zmp(self, com_position, com_acceleration):
              """Calculate ZMP from COM position and acceleration"""
              # ZMP = COM_xy - (COM_height / gravity) * COM_acceleration_xy
              zmp_x = com_position[0] - (self.com_height / self.gravity) * com_acceleration[0]
              zmp_y = com_position[1] - (self.com_height / self.gravity) * com_acceleration[1]
              return np.array([zmp_x, zmp_y])

          def calculate_com_reference(self, time, omega=1.0):
              """Calculate reference COM trajectory for periodic motion"""
              # Generate periodic reference trajectory
              ref_x = 0.01 * math.sin(omega * time)  # Small oscillation
              ref_y = 0.01 * math.cos(omega * time)
              return np.array([ref_x, ref_y, self.com_height])

          def balance_control_law(self, current_zmp, reference_zmp, dt=0.01):
              """Simple balance control law"""
              # PD controller for ZMP tracking
              kp = 10.0
              kd = 1.0

              zmp_error = reference_zmp - current_zmp
              control_output = kp * zmp_error  # Simplified control

              return control_output

      class SupportPolygon:
          """Define support polygon for balance"""
          def __init__(self):
              self.left_foot_pos = np.array([0.0, 0.1, 0.0])  # Default positions
              self.right_foot_pos = np.array([0.0, -0.1, 0.0])
              self.support_polygon = self.calculate_support_polygon()

          def update_foot_positions(self, left_pos, right_pos):
              """Update foot positions and recalculate support polygon"""
              self.left_foot_pos = np.array(left_pos)
              self.right_foot_pos = np.array(right_pos)
              self.support_polygon = self.calculate_support_polygon()

          def calculate_support_polygon(self):
              """Calculate support polygon from foot positions"""
              # For two feet, support polygon is the convex hull of both feet
              # Simplified as a rectangle for this example
              min_x = min(self.left_foot_pos[0], self.right_foot_pos[0]) - 0.1
              max_x = max(self.left_foot_pos[0], self.right_foot_pos[0]) + 0.1
              min_y = min(self.left_foot_pos[1], self.right_foot_pos[1]) - 0.1
              max_y = max(self.left_foot_pos[1], self.right_foot_pos[1]) + 0.1

              return {
                  'min_x': min_x, 'max_x': max_x,
                  'min_y': min_y, 'max_y': max_y
              }

          def is_stable(self, com_position):
              """Check if COM is within support polygon"""
              return (self.support_polygon['min_x'] <= com_position[0] <= self.support_polygon['max_x'] and
                      self.support_polygon['min_y'] <= com_position[1] <= self.support_polygon['max_y'])

      class WholeBodyController(Node):
          """ROS2 node for whole-body control of humanoid robot"""
          def __init__(self):
              super().__init__('whole_body_controller')

              # Publishers and subscribers
              self.joint_state_sub = self.create_subscription(
                  JointState, '/joint_states', self.joint_state_callback, 10)
              self.imu_sub = self.create_subscription(
                  Imu, '/imu/data', self.imu_callback, 10)
              self.balance_cmd_pub = self.create_publisher(
                  JointState, '/balance_commands', 10)
              self.com_pub = self.create_publisher(
                  Point, '/center_of_mass', 10)
              self.zmp_pub = self.create_publisher(
                  Point, '/zero_moment_point', 10)
              self.balance_status_pub = self.create_publisher(
                  Bool, '/balance_status', 10)

              # Initialize controllers
              self.com_estimator = CenterOfMassEstimator()
              self.zmp_controller = ZeroMomentPointController()
              self.support_polygon = SupportPolygon()

              # Robot state
              self.joint_positions = {}
              self.joint_velocities = {}
              self.imu_data = None

              # Control parameters
              self.control_dt = 0.01  # 100Hz control
              self.balance_gains = {'kp': 50.0, 'kd': 10.0}

              # Timer for control loop
              self.control_timer = self.create_timer(self.control_dt, self.balance_control_loop)

              self.get_logger().info('Whole Body Controller initialized')

          def joint_state_callback(self, msg):
              """Update joint state information"""
              for i, name in enumerate(msg.name):
                  if i < len(msg.position):
                      self.joint_positions[name] = msg.position[i]
                  if i < len(msg.velocity):
                      self.joint_velocities[name] = msg.velocity[i]

          def imu_callback(self, msg):
              """Update IMU data"""
              self.imu_data = msg

          def balance_control_loop(self):
              """Main balance control loop"""
              if not self.joint_positions:
                  return

              try:
                  # Update COM estimation
                  self.com_estimator.update_com(self.joint_positions, self.joint_velocities)
                  com_pos, com_vel = self.com_estimator.get_com_state()

                  # Estimate COM acceleration (simplified)
                  # In real implementation, this would use more sophisticated estimation
                  com_acc = np.array([0.0, 0.0, 0.0])
                  if len(self.com_estimator.com_history) > 2:
                      dt = self.control_dt
                      prev_vel = (self.com_estimator.com_history[-2] - self.com_estimator.com_history[-3]) / dt
                      com_acc = (com_vel - prev_vel) / dt

                  # Calculate ZMP
                  current_zmp = self.zmp_controller.calculate_zmp(com_pos, com_acc)

                  # Calculate reference ZMP (for this example, try to keep ZMP at origin)
                  reference_zmp = np.array([0.0, 0.0])

                  # Check support polygon (simplified - in real implementation, get actual foot positions)
                  left_foot_pos = [
                      self.joint_positions.get('left_ankle_pitch', 0.0) * 0.05,
                      0.1,  # Fixed Y position for left foot
                      0.0
                  ]
                  right_foot_pos = [
                      self.joint_positions.get('right_ankle_pitch', 0.0) * 0.05,
                      -0.1,  # Fixed Y position for right foot
                      0.0
                  ]
                  self.support_polygon.update_foot_positions(left_foot_pos, right_foot_pos)

                  # Check if robot is stable
                  is_stable = self.support_polygon.is_stable(com_pos)

                  # Generate balance control commands
                  balance_correction = self.zmp_controller.balance_control_law(
                      current_zmp, reference_zmp, self.control_dt)

                  # Apply balance corrections to joint commands
                  balance_commands = self.generate_balance_commands(balance_correction, com_pos, com_vel)

                  # Publish results
                  self.publish_balance_state(com_pos, current_zmp, is_stable, balance_commands)

              except Exception as e:
                  self.get_logger().error(f'Error in balance control: {e}')

          def generate_balance_commands(self, balance_correction, com_pos, com_vel):
              """Generate joint commands for balance correction"""
              # This is a simplified balance control
              # In real implementation, this would use whole-body inverse kinematics
              # or other sophisticated control methods

              commands = JointState()
              commands.header.stamp = self.get_clock().now().to_msg()
              commands.header.frame_id = 'base_link'

              # Define joints to control for balance
              balance_joints = [
                  'left_hip_pitch', 'right_hip_pitch',
                  'left_ankle_pitch', 'right_ankle_pitch',
                  'left_ankle_roll', 'right_ankle_roll'
              ]

              # Calculate balance adjustments based on COM deviation
              hip_pitch_adjust = balance_correction[1] * 0.1  # Y correction affects hip pitch
              ankle_pitch_adjust = -balance_correction[1] * 0.05  # Inverse for ankle
              ankle_roll_adjust = balance_correction[0] * 0.05  # X correction affects roll

              # Set joint commands
              for joint_name in balance_joints:
                  commands.name.append(joint_name)

                  if 'hip_pitch' in joint_name:
                      # Adjust hip pitch based on balance needs
                      base_pos = self.joint_positions.get(joint_name, 0.0)
                      adjustment = hip_pitch_adjust if 'left' in joint_name else -hip_pitch_adjust
                      commands.position.append(base_pos + adjustment)
                  elif 'ankle_pitch' in joint_name:
                      # Adjust ankle pitch for balance
                      base_pos = self.joint_positions.get(joint_name, 0.0)
                      adjustment = ankle_pitch_adjust if 'left' in joint_name else -ankle_pitch_adjust
                      commands.position.append(base_pos + adjustment)
                  elif 'ankle_roll' in joint_name:
                      # Adjust ankle roll for balance
                      base_pos = self.joint_positions.get(joint_name, 0.0)
                      adjustment = ankle_roll_adjust if 'left' in joint_name else -ankle_roll_adjust
                      commands.position.append(base_pos + adjustment)
                  else:
                      # Default: maintain current position
                      commands.position.append(self.joint_positions.get(joint_name, 0.0))

                  # Add velocity and effort commands
                  commands.velocity.append(0.0)  # Target velocity
                  commands.effort.append(0.0)    # Target effort

              return commands

          def publish_balance_state(self, com_pos, zmp_pos, is_stable, balance_commands):
              """Publish balance state information"""
              # Publish COM position
              com_msg = Point()
              com_msg.x = float(com_pos[0])
              com_msg.y = float(com_pos[1])
              com_msg.z = float(com_pos[2])
              self.com_pub.publish(com_msg)

              # Publish ZMP position
              zmp_msg = Point()
              zmp_msg.x = float(zmp_pos[0])
              zmp_msg.y = float(zmp_pos[1])
              zmp_msg.z = 0.0  # ZMP is on ground plane
              self.zmp_pub.publish(zmp_msg)

              # Publish balance status
              status_msg = Bool()
              status_msg.data = is_stable
              self.balance_status_pub.publish(status_msg)

              # Publish balance commands
              self.balance_cmd_pub.publish(balance_commands)

              # Log balance information
              self.get_logger().debug(
                  f'COM: ({com_pos[0]:.3f}, {com_pos[1]:.3f}, {com_pos[2]:.3f}), '
                  f'ZMP: ({zmp_pos[0]:.3f}, {zmp_pos[1]:.3f}), '
                  f'Stable: {is_stable}'
              )

      def main(args=None):
          rclpy.init(args=args)
          node = WholeBodyController()

          try:
              rclpy.spin(node)
          except KeyboardInterrupt:
              node.get_logger().info('Shutting down whole body controller...')
          finally:
              node.destroy_node()
              rclpy.shutdown()

      if __name__ == '__main__':
          main()

  -
    title: "Dynamic Walking Pattern Generation"
    description: "Implementation of dynamic walking pattern generation for humanoid robots"
    language: "python"
    framework: "ROS2 with Trajectory Generation"
    code: |
      #!/usr/bin/env python3
      """
      Dynamic Walking Pattern Generation
      Demonstrates dynamic walking pattern generation for humanoid robots
      """
      import rclpy
      from rclpy.node import Node
      from sensor_msgs.msg import JointState
      from geometry_msgs.msg import Twist, Point
      from std_msgs.msg import Float64MultiArray, Bool
      import numpy as np
      import math
      from typing import List, Tuple
      import time

      class WalkingPatternGenerator:
          """Generate walking patterns for humanoid robots"""
          def __init__(self):
              self.step_length = 0.3  # 30cm step length
              self.step_width = 0.2   # 20cm step width (distance between feet)
              self.step_height = 0.05 # 5cm step height
              self.step_duration = 1.0  # 1 second per step
              self.zmp_offset = 0.02  # ZMP offset for stability

          def generate_double_support_phase(self, start_pos, end_pos, duration, num_points=10):
              """Generate double support phase trajectory"""
              trajectory = []
              for i in range(num_points):
                  t = i / (num_points - 1) if num_points > 1 else 0
                  x = start_pos[0] + t * (end_pos[0] - start_pos[0])
                  y = start_pos[1] + t * (end_pos[1] - start_pos[1])
                  z = start_pos[2] + t * (end_pos[2] - start_pos[2])
                  trajectory.append(np.array([x, y, z]))
              return trajectory

          def generate_single_support_phase(self, start_pos, end_pos, max_height, num_points=20):
              """Generate single support phase with parabolic trajectory"""
              trajectory = []
              for i in range(num_points):
                  t = i / (num_points - 1) if num_points > 1 else 0

                  # Linear interpolation for x, y
                  x = start_pos[0] + t * (end_pos[0] - start_pos[0])
                  y = start_pos[1] + t * (end_pos[1] - start_pos[1])

                  # Parabolic trajectory for z (step height)
                  z = start_pos[2] + t * (end_pos[2] - start_pos[2])
                  z += max_height * math.sin(math.pi * t)  # Add step height

                  trajectory.append(np.array([x, y, z]))
              return trajectory

          def generate_walking_trajectory(self, num_steps: int, step_type: str = 'forward') -> List[np.array]:
              """Generate complete walking trajectory"""
              trajectory = []

              # Starting positions for feet
              left_foot_pos = np.array([0.0, self.step_width/2, 0.0])
              right_foot_pos = np.array([0.0, -self.step_width/2, 0.0])

              # Generate steps
              for step in range(num_steps):
                  if step % 2 == 0:  # Even steps: move right foot
                      # Single support: right foot moves forward
                      next_right_pos = right_foot_pos + np.array([self.step_length, 0, 0])
                      single_support = self.generate_single_support_phase(
                          right_foot_pos, next_right_pos, self.step_height)
                      trajectory.extend(single_support)

                      # Update position
                      right_foot_pos = next_right_pos

                      # Double support phase
                      if step < num_steps - 1:  # Not the last step
                          double_support = self.generate_double_support_phase(
                              left_foot_pos, left_foot_pos, self.step_duration/4)
                          trajectory.extend(double_support)

                  else:  # Odd steps: move left foot
                      # Single support: left foot moves forward
                      next_left_pos = left_foot_pos + np.array([self.step_length, 0, 0])
                      single_support = self.generate_single_support_phase(
                          left_foot_pos, next_left_pos, self.step_height)
                      trajectory.extend(single_support)

                      # Update position
                      left_foot_pos = next_left_pos

                      # Double support phase
                      if step < num_steps - 1:  # Not the last step
                          double_support = self.generate_double_support_phase(
                              right_foot_pos, right_foot_pos, self.step_duration/4)
                          trajectory.extend(double_support)

              return trajectory

          def generate_com_trajectory(self, foot_trajectory: List[np.array], dt: float = 0.01) -> List[np.array]:
              """Generate Center of Mass trajectory following foot placement"""
              # Simplified COM trajectory generation
              # In real implementation, this would use more sophisticated methods
              com_trajectory = []

              # For this example, COM follows a smoothed version of foot trajectory
              for i, foot_pos in enumerate(foot_trajectory):
                  # Simple COM offset from foot (this is highly simplified)
                  com_offset = np.array([0.0, 0.0, 0.8])  # Fixed height

                  # Add some smoothing to make motion more natural
                  if i > 0 and i < len(foot_trajectory) - 1:
                      prev_pos = foot_trajectory[i-1]
                      next_pos = foot_trajectory[i+1]
                      smooth_pos = (prev_pos + foot_pos + next_pos) / 3.0
                      com_pos = smooth_pos + com_offset
                  else:
                      com_pos = foot_pos + com_offset

                  com_trajectory.append(com_pos)

              return com_trajectory

      class DynamicWalkingController(Node):
          """ROS2 node for dynamic walking control"""
          def __init__(self):
              super().__init__('dynamic_walking_controller')

              # Publishers and subscribers
              self.joint_cmd_pub = self.create_publisher(
                  JointState, '/dynamic_walk_commands', 10)
              self.walk_cmd_sub = self.create_subscription(
                  Twist, '/cmd_walk', self.walk_command_callback, 10)
              self.com_trajectory_pub = self.create_publisher(
                  Point, '/com_trajectory', 10)
              self.foot_trajectory_pub = self.create_publisher(
                  Point, '/foot_trajectory', 10)
              self.walk_status_pub = self.create_publisher(
                  Bool, '/walking_status', 10)

              # Initialize walking components
              self.pattern_generator = WalkingPatternGenerator()
              self.current_trajectory = []
              self.trajectory_index = 0
              self.is_walking = False

              # Walking parameters
              self.walking_speed = 0.0  # Current walking speed
              self.walking_direction = 0.0  # Turning direction
              self.step_frequency = 1.0  # Steps per second

              # Timer for walking execution
              self.walk_timer = self.create_timer(0.05, self.walk_execution_callback)  # 20Hz

              self.get_logger().info('Dynamic Walking Controller initialized')

          def walk_command_callback(self, msg):
              """Handle walking commands"""
              linear_x = msg.linear.x
              angular_z = msg.angular.z

              # Update walking parameters
              self.walking_speed = linear_x
              self.walking_direction = angular_z

              # Generate walking trajectory based on command
              if abs(linear_x) > 0.01 or abs(angular_z) > 0.01:
                  self.start_walking()
              else:
                  self.stop_walking()

          def start_walking(self):
              """Start walking with current parameters"""
              if not self.is_walking:
                  self.get_logger().info('Starting dynamic walking')

                  # Calculate number of steps based on speed
                  num_steps = 10  # Generate 10 steps ahead

                  # Generate walking trajectory
                  self.current_trajectory = self.pattern_generator.generate_walking_trajectory(
                      num_steps, 'forward')

                  self.trajectory_index = 0
                  self.is_walking = True

                  # Publish walking status
                  status_msg = Bool()
                  status_msg.data = True
                  self.walk_status_pub.publish(status_msg)

          def stop_walking(self):
              """Stop walking"""
              if self.is_walking:
                  self.get_logger().info('Stopping dynamic walking')
                  self.is_walking = False

                  # Publish walking status
                  status_msg = Bool()
                  status_msg.data = False
                  self.walk_status_pub.publish(status_msg)

          def walk_execution_callback(self):
              """Execute walking based on trajectory"""
              if not self.is_walking or not self.current_trajectory:
                  return

              # Check if we need to regenerate trajectory
              if self.trajectory_index >= len(self.current_trajectory):
                  # Generate new trajectory
                  self.current_trajectory = self.pattern_generator.generate_walking_trajectory(
                      10, 'forward')
                  self.trajectory_index = 0

              # Get current target position from trajectory
              target_pos = self.current_trajectory[self.trajectory_index]

              # Generate joint commands for target position
              joint_commands = self.generate_joint_commands_from_foot_pos(target_pos)

              # Publish joint commands
              self.joint_cmd_pub.publish(joint_commands)

              # Publish trajectory information
              self.publish_trajectory_info(target_pos)

              # Increment trajectory index
              self.trajectory_index += 1

              # Log walking information
              self.get_logger().debug(
                  f'Walking - Speed: {self.walking_speed:.2f}, '
                  f'Direction: {self.walking_direction:.2f}, '
                  f'Traj idx: {self.trajectory_index}/{len(self.current_trajectory)}'
              )

          def generate_joint_commands_from_foot_pos(self, foot_pos) -> JointState:
              """Generate joint commands from desired foot position using inverse kinematics"""
              # This is a simplified joint command generation
              # In real implementation, this would use full inverse kinematics

              joint_state = JointState()
              joint_state.header.stamp = self.get_clock().now().to_msg()
              joint_state.header.frame_id = 'base_link'

              # Define joint names for a simple humanoid model
              joint_names = [
                  'left_hip_yaw', 'left_hip_pitch', 'left_hip_roll',
                  'left_knee', 'left_ankle_pitch', 'left_ankle_roll',
                  'right_hip_yaw', 'right_hip_pitch', 'right_hip_roll',
                  'right_knee', 'right_ankle_pitch', 'right_ankle_roll'
              ]

              # Calculate joint positions based on desired foot position
              # This is a simplified calculation - real IK would be more complex
              joint_positions = []

              for i, name in enumerate(joint_names):
                  if 'left' in name:
                      # Left leg - use foot position to determine joint angles
                      if 'hip_pitch' in name:
                          # Hip pitch affects forward/backward position
                          base_angle = 0.0
                          if foot_pos[0] > 0.1:
                              base_angle = -0.1  # Lean back for forward position
                          joint_positions.append(base_angle)
                      elif 'knee' in name:
                          # Knee angle based on desired leg extension
                          base_angle = 0.0
                          if foot_pos[2] > 0.02:  # If foot is raised
                              base_angle = 0.5   # Bend knee
                          joint_positions.append(base_angle)
                      elif 'ankle' in name:
                          # Ankle angle for balance
                          joint_positions.append(foot_pos[1] * 0.5)  # Balance based on Y position
                      else:
                          joint_positions.append(0.0)
                  else:
                      # Right leg - similar to left but mirrored
                      if 'hip_pitch' in name:
                          base_angle = 0.0
                          if foot_pos[0] > 0.1:
                              base_angle = -0.1
                          joint_positions.append(base_angle)
                      elif 'knee' in name:
                          base_angle = 0.0
                          if foot_pos[2] > 0.02:
                              base_angle = 0.5
                          joint_positions.append(base_angle)
                      elif 'ankle' in name:
                          joint_positions.append(-foot_pos[1] * 0.5)  # Mirror left leg
                      else:
                          joint_positions.append(0.0)

              # Set joint state
              joint_state.name = joint_names
              joint_state.position = joint_positions
              joint_state.velocity = [0.0] * len(joint_positions)
              joint_state.effort = [0.0] * len(joint_positions)

              return joint_state

          def publish_trajectory_info(self, current_pos):
              """Publish trajectory information for visualization"""
              # Publish foot trajectory point
              foot_msg = Point()
              foot_msg.x = float(current_pos[0])
              foot_msg.y = float(current_pos[1])
              foot_msg.z = float(current_pos[2])
              self.foot_trajectory_pub.publish(foot_msg)

              # Publish COM trajectory point (simplified)
              com_msg = Point()
              com_msg.x = float(current_pos[0])  # COM roughly follows foot in X
              com_msg.y = 0.0  # COM stays centered in Y
              com_msg.z = 0.8   # COM fixed height
              self.com_trajectory_pub.publish(com_msg)

      def main(args=None):
          rclpy.init(args=args)
          node = DynamicWalkingController()

          try:
              rclpy.spin(node)
          except KeyboardInterrupt:
              node.get_logger().info('Shutting down dynamic walking controller...')
          finally:
              node.stop_walking()
              node.destroy_node()
              rclpy.shutdown()

      if __name__ == '__main__':
          main()

practical_examples:
  -
    title: "Humanoid Balance Control System"
    description: "Students implement a complete balance control system for a humanoid robot using whole-body control and ZMP-based stability."
    objectives:
      - "Implement center of mass estimation"
      - "Create ZMP-based balance controller"
      - "Develop support polygon calculation"
      - "Test stability on simulated humanoid"
    required_components:
      - "Humanoid robot model"
      - "IMU and joint position sensors"
      - "Whole-body control framework"
      - "Balance control algorithms"
      - "Simulation environment"
    evaluation_criteria:
      - "Balance stability under disturbances"
      - "Recovery from perturbations"
      - "Smooth motion execution"
      - "Computational efficiency"
  -
    title: "Dynamic Walking Gait Generation"
    description: "Students develop a dynamic walking system that can generate stable gaits for different walking speeds and directions."
    objectives:
      - "Implement walking pattern generation"
      - "Create smooth trajectory interpolation"
      - "Develop adaptive gait parameters"
      - "Validate walking stability"
    required_components:
      - "Humanoid robot platform"
      - "Footstep planning algorithms"
      - "Trajectory generation tools"
      - "Balance control system"
      - "Motion capture for validation"
    evaluation_criteria:
      - "Walking stability and smoothness"
      - "Adaptation to different speeds"
      - "Energy efficiency"
      - "Robustness to disturbances"
  -
    title: "Humanoid Locomotion Learning"
    description: "Students create a learning system that improves humanoid locomotion through experience and human demonstration."
    objectives:
      - "Implement locomotion learning algorithms"
      - "Create demonstration recording system"
      - "Develop policy improvement methods"
      - "Validate learning effectiveness"
    required_components:
      - "Humanoid robot with learning capabilities"
      - "Learning algorithm implementation"
      - "Performance evaluation tools"
      - "Human demonstration interface"
      - "Safety monitoring systems"
    evaluation_criteria:
      - "Learning speed and effectiveness"
      - "Improvement over time"
      - "Generalization to new conditions"
      - "Safety and reliability"

summary: "Chapter 17 covered humanoid locomotion and control, including inverse kinematics, whole-body control, balance maintenance, and dynamic walking. Students learned to implement control systems for humanoid robots, focusing on stability, efficiency, and human-like movement patterns. The chapter emphasized the importance of balance control, ZMP concepts, and coordinated movement for creating robots that can operate effectively in human environments."

quiz:
  -
    question: "What does ZMP stand for in humanoid robotics?"
    options:
      - A: Zero Moment Point
      - B: Zero Motion Position
      - C: Zed Motor Processor
      - D: Zone Management Protocol
    correct_answer: "A"
    explanation: "ZMP stands for Zero Moment Point, a key concept in humanoid balance control."
  -
    question: "What is the primary purpose of inverse kinematics in humanoid robots?"
    options:
      - A: To determine joint angles from end-effector positions
      - B: To increase robot speed
      - C: To reduce power consumption
      - D: To simplify robot design
    correct_answer: "A"
    explanation: "Inverse kinematics determines the joint angles needed to achieve desired end-effector positions."
  -
    question: "What is the support polygon in humanoid balance?"
    options:
      - A: The area where the robot can move
      - B: The convex hull of contact points with the ground
      - C: A type of polygon shape
      - D: The robot's walking path
    correct_answer: "B"
    explanation: "The support polygon is the convex hull of contact points between the robot and ground, defining the stable region."
  -
    question: "Why is whole-body control important for humanoid robots?"
    options:
      - A: It reduces manufacturing costs
      - B: It coordinates all joints for stable and efficient movement
      - C: It makes robots physically stronger
      - D: It eliminates the need for programming
    correct_answer: "B"
    explanation: "Whole-body control coordinates all joints to achieve stable and efficient movement patterns."
  -
    question: "What does the center of mass (COM) represent in humanoid balance?"
    options:
      - A: The heaviest part of the robot
      - B: The average position of all mass in the robot
      - C: The robot's height
      - D: The robot's walking speed
    correct_answer: "B"
    explanation: "The center of mass represents the average position of all mass in the robot, crucial for balance control."

module_learning_outcomes:
  - "Implement multimodal learning systems"
  - "Integrate vision, language, and action components"
  - "Develop interactive learning algorithms"
  - "Create human-robot interaction systems"

prerequisites:
  - "Basic understanding of Python programming"
  - "Fundamentals of linear algebra and calculus"
  - "Basic knowledge of robotics concepts"
  - "Introduction to machine learning concepts"
  - "Completion of Module 0 (Introduction and Foundations)"
  - "Completion of Chapter 01 (Physical AI Basics)"
  - "Completion of Chapter 03 (ROS2 Nodes, Topics & Services)"
  - "Completion of Chapter 16 (Vision-Language-Action Concepts)"

estimated_duration: "6 hours"
...